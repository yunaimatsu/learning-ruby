## 2. 継承とメッセージ

継承を使うと、別のクラスを基にして、新しいクラスを作成することができます。例えば、私たちのジュークボックスには「曲」という概念があり、これをSongクラスで表現しています。そこにマーケティング担当者がやってきて、カラオケ機能を追加するように言われました。カラオケの曲は、他の曲とほとんど同じですが（歌声は入っていませんが、それは問題ではありません）、歌詞とタイミング情報を持っています。ジュークボックスがカラオケ曲を再生するとき、歌詞は曲の進行に合わせてジュークボックスの画面に流れる必要があります。

この問題に対処するためには、新しいクラスKaraokeSongを定義します。KaraokeSongはSongとほとんど同じですが、歌詞トラックを追加します。

class KaraokeSong < Song
  def initialize(name, artist, duration, lyrics)
    super(name, artist, duration)
    @lyrics = lyrics
  end
end

< Songというクラス定義の行は、KaraokeSongがSongのサブクラスであることをRubyに伝えます。（予想通り、これによりSongはKaraokeSongの親クラスになります。人々はこれを親子関係と呼ぶこともあります。）今のところ、initializeメソッドについては心配しないでください。superの使い方については後で説明します。

それでは、KaraokeSongを作成して、コードが動作するか確認してみましょう。（最終システムでは、歌詞はテキストとタイミング情報を含むオブジェクトに格納されますが、ここでは単に文字列を使ってテストします。これは型がない言語のもう一つの利点です---コードを実行し始める前にすべてを定義する必要はありません。）

aSong = KaraokeSong.new("My Way", "Sinatra", 225, "And now, the...")
aSong.to_s  # => "Song: My Way--Sinatra (225)"

実行はできましたが、なぜto_sメソッドに歌詞が表示されないのでしょうか？

その答えは、Rubyがメッセージがオブジェクトに送られたときに、どのメソッドを呼び出すべきかをどのように決定するかに関係しています。RubyがaSong.to_sというメソッド呼び出しをコンパイルするとき、実際にはto_sメソッドがどこにあるかはわかりません。そのため、プログラムが実行されるまで決定を遅延させます。そのとき、RubyはaSongのクラスを見て、そのクラスがメッセージと同じ名前のメソッドを実装していれば、そのメソッドを実行します。もし見つからなければ、Rubyは親クラス、さらに親クラスを遡って探します。もし適切なメソッドが見つからなければ、特別な処理が行われ、通常はエラーが発生します。

では、私たちの例に戻りましょう。to_sメソッドをaSongというKaraokeSongクラスのオブジェクトに送ったところ、RubyはKaraokeSongクラス内でto_sメソッドを見つけられませんでした。そのため、RubyはKaraokeSongの親であるSongクラスを調べ、そこに私たちがページ18で定義したto_sメソッドを見つけたのです。だから、歌詞が表示されないのです。Songクラスは歌詞について何も知りません。

class KaraokeSong
  # ...
  def to_s
    "KS: #{@name}--#{@artist} (#{@duration}) [#{@lyrics}]"
  end
end

再度テストしてみましょう。

aSong = KaraokeSong.new("My Way", "Sinatra", 225, "And now, the...")
aSong.to_s  # => "KS: My Way--Sinatra (225) [And now, the...]"

これで、@lyricsインスタンス変数の値が正しく表示されるようになりました。しかし、この実装には問題があります。なぜなら、親クラスの内部状態に直接アクセスしているからです。これにより、親クラスの実装に強く依存することになります。例えば、もしSongクラスを変更して曲の長さをミリ秒単位で保存するようにした場合、KaraokeSongは突飛な値を表示することになってしまいます。たとえば、「『My Way』のカラオケバージョンが3750分も続く」というのはあまりにも怖すぎます。

この問題を回避するために、各クラスは自分の内部状態を管理します。KaraokeSong#to_sが呼ばれると、まず親のto_sメソッドを呼び出して曲の詳細を取得し、それに歌詞情報を追加して結果を返すようにします。ここで使うのがRubyのsuperキーワードです。superを引数なしで呼び出すと、Rubyは現在のオブジェクトの親にメッセージを送り、親の同名のメソッドを呼び出します。その際、現在のメソッドに渡された引数も親に渡されます。

それでは、新しいto_sメソッドを実装してみましょう。

class KaraokeSong < Song
  # 自分を文字列としてフォーマットするために
  # 親の#to_sの値に歌詞を追加します。
  def to_s
    super + " [#{@lyrics}]"
  end
end

再度テストしてみます。

aSong = KaraokeSong.new("My Way", "Sinatra", 225, "And now, the...")
aSong.to_s  # => "Song: My Way--Sinatra (225) [And now, the...]"

これで、歌詞が正しく表示されるようになりました。また、Songクラスに親クラスが明示的に指定されていませんが、Songクラスは暗黙のうちにObjectクラスを親として持っています。これにより、すべてのオブジェクトはObjectクラスを祖先として持ち、そのインスタンスメソッドはすべてのオブジェクトで利用可能です。to_sもその一例で、Objectクラスに35以上のインスタンスメソッドが定義されています。

