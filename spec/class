## 1. 導入

これまでの例を見て、Rubyがオブジェクト指向言語だという主張について疑問に思っているかもしれません。さて、この章ではその主張をどのように証明するかについて説明します。Rubyでクラスとオブジェクトを作成する方法や、Rubyが多くのオブジェクト指向言語よりも強力である点について見ていきます。その過程で、次の億ドル製品「インターネット対応ジャズ＆ブルーグラスジュークボックス」の一部を実装していきます。

数ヶ月にわたる作業の結果、我々の高給取りの研究開発チームは、ジュークボックスには曲が必要だと結論しました。そこで、まずは「曲」を表すRubyのクラスを作成するのが良い考えだとわかりました。実際の曲には名前、アーティスト、再生時間があるので、プログラム内の曲オブジェクトにもそれらを持たせる必要があります。

まずは基本的なクラスSongを作成し、単一のメソッドinitializeだけを含めてみます。

class Song
  def initialize(name, artist, duration)
    @name     = name
    @artist   = artist
    @duration = duration
  end
end

initializeはRubyプログラムで特別なメソッドです。Song.newを呼び出して新しいSongオブジェクトを作成すると、Rubyは初期化されていないオブジェクトを作成し、そのオブジェクトのinitializeメソッドを呼び出します。この際、newに渡された引数がinitializeメソッドに渡されます。これにより、オブジェクトの状態を設定するためのコードを書くことができます。

Songクラスの場合、initializeメソッドは3つのパラメータを受け取ります。これらのパラメータはメソッド内でローカル変数のように扱われ、ローカル変数の命名規則に従い、小文字で始まります。

各オブジェクトはそれぞれ独自の曲を表しているので、Songオブジェクトごとに名前、アーティスト、再生時間を保持する必要があります。これには、オブジェクト内でインスタンス変数としてこれらの値を保存します。Rubyではインスタンス変数は名前の前に「@」を付けるだけで表現できます。例えば、パラメータnameはインスタンス変数@nameに、artistは@artistに、durationは@durationにそれぞれ割り当てられます。

では、この新しいクラスをテストしてみましょう。

aSong = Song.new("Bicylops", "Fleck", 260)
aSong.inspect  # => "#<Song:0x401b4924 @duration=260, @artist=\"Fleck\", @name=\"Bicylops\">"

うまくいったようです。デフォルトで、inspectメッセージは任意のオブジェクトに送信でき、オブジェクトのIDとインスタンス変数が表示されます。インスタンス変数が正しく設定されていることがわかります。

私たちの経験から、開発中にSongオブジェクトの内容を何度も印刷することになるでしょうが、inspectのデフォルトフォーマットはあまり便利ではありません。幸い、Rubyにはすべてのオブジェクトに対して文字列として表示されるto_sという標準メソッドがあります。これを曲に試してみましょう。

aSong = Song.new("Bicylops", "Fleck", 260)
aSong.to_s  # => "#<Song:0x401b499c>"

あまり役に立ちませんでしたね—オブジェクトIDだけが表示されました。そこで、to_sメソッドをクラス内でオーバーライドしてみましょう。この機会に、私たちがこの本でどのようにクラス定義を示しているかについても触れておきましょう。

Rubyでは、クラスは決して閉じられることはありません。既存のクラスに新しいメソッドを追加することができます。これには、自分で作成したクラスだけでなく、標準の組み込みクラスも含まれます。既存のクラス定義を開くことで、新しい内容がそのクラスに追加されます。

これは私たちにとって非常に便利です。この章を通して、クラスに機能を追加していく過程で、新しいメソッドだけをクラス定義として示し、古いものはそのままにしておきます。これにより、各例で冗長なコードを繰り返す必要がなくなります。もちろん、もしこのコードを最初から作成するのであれば、すべてのメソッドを一つのクラス定義内に書くことになるでしょう。

さて、詳細はここまでにして、Songクラスにto_sメソッドを追加しましょう。

class Song
  def to_s
    "Song: #{@name}--#{@artist} (#{@duration})"
  end
end

aSong = Song.new("Bicylops", "Fleck", 260)
aSong.to_s  # => "Song: Bicylops--Fleck (260)"

素晴らしい、進展があります。しかし、ここで少し微妙な点を見落としました。Rubyがすべてのオブジェクトにto_sをサポートしていると述べましたが、その仕組みについては説明していませんでした。その答えは、継承、サブクラス化、そしてRubyがオブジェクトにメッセージを送る際にどのメソッドを実行するかをどのように決定するかに関係しています。これは次のセクションで扱う内容です。

