## 1. コンテナ、ブロック、イテレータ

1曲だけのジュークボックスは人気が出ないでしょう（ごく一部の非常に怖いバーを除いて）。そのため、すぐにカタログと再生リストを作成し、再生する曲のリストを管理する必要が出てきます。これらはどちらもコンテナです。コンテナとは、1つまたは複数の他のオブジェクトへの参照を保持するオブジェクトのことです。

カタログと再生リストには、曲を追加する、削除する、曲のリストを返す、といった似たようなメソッドが必要です。再生リストは、広告を挿入したり、累積再生時間を追跡したりといった追加のタスクを実行するかもしれませんが、その点については後で考えることにしましょう。とりあえず、カタログと再生リストの両方に対応できるような、汎用的なSongListクラスを開発するのが良いアイデアです。

## 2. コンテナ

実装を始める前に、SongListオブジェクト内に曲のリストをどのように格納するかを考える必要があります。ここで考えられる選択肢は3つあります。RubyのArray型を使う、RubyのHash型を使う、または自分でリスト構造を作成するという方法です。今回は面倒なので、ArrayとHashを見てみて、どちらかをクラスに使うことにしましょう。

## 3. 配列

クラスArrayは、オブジェクトの参照のコレクションを保持します。各オブジェクトの参照は、配列内の位置を表す非負の整数インデックスによって識別されます。

配列は、リテラルを使用するか、明示的にArrayオブジェクトを作成して作成できます。リテラル配列は、単に角括弧内にオブジェクトを並べたものです。

a = [ 3.14159, "pie", 99 ]
a.type    # => Array
a.length  # => 3
a[0]      # => 3.14159
a[1]      # => "pie"
a[2]      # => 99
a[3]      # => nil

b = Array.new
b.type    # => Array
b.length  # => 0
b[0] = "second"
b[1] = "array"
b  # => ["second", "array"]

配列は[]演算子を使ってインデックス指定します。ほとんどのRubyの演算子と同様に、これは実際にはメソッド（Arrayクラス内）であり、サブクラスでオーバーライドすることができます。上記の例のように、配列のインデックスは0から始まります。単一の整数で配列をインデックス指定すると、その位置にあるオブジェクトが返されます。もしそこにオブジェクトがなければ、nilが返されます。負の整数でインデックス指定すると、配列の末尾からカウントされます。

a = [ 1, 3, 5, 7, 9 ]
a[-1]  # => 9
a[-2]  # => 7
a[-99] # => nil

また、配列は2つの数値（[start, count]）を使ってインデックス指定できます。これは、start位置からcount個のオブジェクトを参照する新しい配列を返します。

a = [ 1, 3, 5, 7, 9 ]
a[1, 3]  # => [3, 5, 7]
a[3, 1]  # => [7]
a[-3, 2] # => [5, 7]

最後に、範囲を使って配列をインデックス指定できます。範囲は2つまたは3つのドットで区切られた開始位置と終了位置で構成されます。2ドット形式は終了位置を含み、3ドット形式は終了位置を含みません。

a = [ 1, 3, 5, 7, 9 ]
a[1..3]  # => [3, 5, 7]
a[1...3] # => [3, 5]
a[3..3]  # => [7]
a[-3..-1] # => [5, 7, 9]

[]演算子には対応する[]=演算子があり、これを使って配列の要素を設定できます。単一の整数インデックスで使用すると、その位置の要素が右辺の値で置き換えられます。結果として空白ができた場合は、nilで埋められます。

a = [ 1, 3, 5, 7, 9 ]  # => [1, 3, 5, 7, 9]
a[1] = 'bat'  # => [1, "bat", 5, 7, 9]
a[-3] = 'cat' # => [1, "bat", "cat", 7, 9]
a[3] = [ 9, 8 ] # => [1, "bat", "cat", [9, 8], 9]
a[6] = 99 # => [1, "bat", "cat", [9, 8], 9, nil, 99]

インデックスが2つの数（開始位置と長さ）や範囲の場合、その位置にある要素が右辺の値で置き換えられます。長さがゼロの場合、右辺の値は開始位置の前に挿入され、要素は削除されません。右辺が配列の場合、その要素が置き換えに使用されます。右辺の要素数と元の配列の要素数が異なる場合でも、配列のサイズは自動的に調整されます。

a = [ 1, 3, 5, 7, 9 ]  # => [1, 3, 5, 7, 9]
a[2, 2] = 'cat'  # => [1, 3, "cat", 9]
a[2, 0] = 'dog'  # => [1, 3, "dog", "cat", 9]
a[1, 1] = [ 9, 8, 7 ]  # => [1, 9, 8, 7, "dog", "cat", 9]
a[0..3] = []  # => ["dog", "cat", 9]
a[5] = 99  # => ["dog", "cat", 9, nil, nil, 99]

配列には、スタック、セット、キュー、デキュー、FIFOとして扱うための便利なメソッドが多数あります。配列メソッドの完全なリストは278ページから始まります。

## 4. ハッシュ

ハッシュ（時々、連想配列や辞書とも呼ばれます）は、配列と似ており、オブジェクト参照のインデックス付き集合です。ただし、配列は整数でインデックスを指定するのに対し、ハッシュでは任意のタイプのオブジェクト（文字列、正規表現など）でインデックスを指定できます。ハッシュに値を格納する際、実際には2つのオブジェクト（キーと値）を提供します。その後、同じキーを使ってハッシュから値を取得することができます。ハッシュの値は、任意のタイプのオブジェクトであっても構いません。

次の例では、ハッシュリテラルを使用しています。これは、波括弧内に「キー => 値」のペアを並べたものです。

h = { 'dog' => 'canine', 'cat' => 'feline', 'donkey' => 'asinine' }
h.length   # => 3
h['dog']   # => "canine"
h['cow'] = 'bovine'
h[12] = 'dodecine'
h['cat'] = 99
h   # => {"cow"=>"bovine", "cat"=>99, 12=>"dodecine", "donkey"=>"asinine", "dog"=>"canine"}

配列と比較して、ハッシュには一つの大きな利点があります。それは、任意のオブジェクトをインデックスとして使える点です。しかし、その反面、ハッシュには大きな欠点もあります。それは、要素が順序付けられていないため、ハッシュをスタックやキューとして簡単に使うことができない点です。

ハッシュは、Rubyで最も一般的に使用されるデータ構造の一つです。クラスHashによって実装されたメソッドの完全なリストは、317ページから始まります。


## 5. SongList コンテナの実装

配列とハッシュについて少し触れた後、いよいよジュークボックスの SongList を実装する準備が整いました。まず、SongList に必要な基本的なメソッドを考えてみましょう。今後追加することになるかもしれませんが、まずはこれで進めます。

append(aSong) » list
指定した曲をリストの末尾に追加します。

deleteFirst() » aSong
リストの先頭の曲を削除し、その曲を返します。

deleteLast() » aSong
リストの末尾の曲を削除し、その曲を返します。

[anIndex] » aSong
指定したインデックス（整数インデックスまたは曲のタイトル）で識別される曲を返します。


このリストを見て、実装の手がかりが得られます。末尾に曲を追加し、先頭と末尾から削除する能力は、ダブルエンドキュー（dequeue）― 両端キューを使うことを示唆しています。これは配列を使って実装できることがわかります。同様に、リスト内の特定の位置にある曲を返す能力も配列でサポートされています。

しかし、曲をタイトルで検索する必要もあり、これにはハッシュを使うことが考えられます。タイトルをキー、曲を値として扱います。ハッシュを使うことは可能でしょうか？ まあ、可能ではありますが、問題もあります。まず、ハッシュは順序付けされていないため、リストを追跡するために補助的な配列が必要になりそうです。さらに大きな問題は、ハッシュは同じ値に対して複数のキーをサポートしないことです。これが私たちのプレイリストでは問題になります。同じ曲が複数回再生リストに並ぶ可能性があるからです。したがって、現時点では曲を配列で管理し、タイトルで検索することにします。この部分がパフォーマンスのボトルネックになれば、後でハッシュベースの検索方法を追加できます。

まず、基本的な initialize メソッドでクラスを作成し、曲を保持するための配列を作り、その参照をインスタンス変数 @songs に格納します。

class SongList
  def initialize
    @songs = Array.new
  end
end

次に、SongList#append メソッドを実装します。指定された曲を @songs 配列の末尾に追加し、self（現在の SongList オブジェクトの参照）を返します。この self を返すことによって、複数の append メソッドを連続して呼び出すことができる便利な慣習を実現しています。後で例を見ていきます。

class SongList
  def append(aSong)
    @songs.push(aSong)
    self
  end
end

次に、deleteFirst と deleteLast メソッドを追加します。これらはそれぞれ、Array#shift と Array#pop を使って簡単に実装できます。

class SongList
  def deleteFirst
    @songs.shift
  end
  def deleteLast
    @songs.pop
  end
end

ここで、簡単なテストを行います。まず、4曲をリストに追加します。追加する際に、append が SongList オブジェクトを返すことを利用して、メソッド呼び出しをチェーンします。

list = SongList.new
list.
  append(Song.new('title1', 'artist1', 1)).
  append(Song.new('title2', 'artist2', 2)).
  append(Song.new('title3', 'artist3', 3)).
  append(Song.new('title4', 'artist4', 4))

次に、リストの先頭と末尾から曲が正しく削除され、リストが空になると nil が返されることを確認します。

list.deleteFirst  # => Song: title1--artist1 (1)
list.deleteFirst  # => Song: title2--artist2 (2)
list.deleteLast   # => Song: title4--artist4 (4)
list.deleteLast   # => Song: title3--artist3 (3)
list.deleteLast   # => nil

順調に進んでいます。次のメソッドは [] で、インデックスで要素にアクセスします。インデックスが数値であれば、その位置にある要素を返します。

class SongList
  def [](key)
    if key.kind_of?(Integer)
      @songs[key]
    else
      # ...
    end
  end
end

これをテストすると、次のようになります。

list[0]  # => Song: title1--artist1 (1)
list[2]  # => Song: title3--artist3 (3)
list[9]  # => nil

最後に、タイトルで曲を検索できる機能を追加します。これには、リスト内の各曲をスキャンし、タイトルをチェックする必要があります。そのために、Rubyの非常に便利な機能であるイテレーターを使う方法を学ぶ必要があります。

