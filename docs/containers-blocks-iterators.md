## 1. コンテナ、ブロック、イテレータ

1曲だけのジュークボックスは人気が出ないでしょう（ごく一部の非常に怖いバーを除いて）。そのため、すぐにカタログと再生リストを作成し、再生する曲のリストを管理する必要が出てきます。これらはどちらもコンテナです。コンテナとは、1つまたは複数の他のオブジェクトへの参照を保持するオブジェクトのことです。

カタログと再生リストには、曲を追加する、削除する、曲のリストを返す、といった似たようなメソッドが必要です。再生リストは、広告を挿入したり、累積再生時間を追跡したりといった追加のタスクを実行するかもしれませんが、その点については後で考えることにしましょう。とりあえず、カタログと再生リストの両方に対応できるような、汎用的なSongListクラスを開発するのが良いアイデアです。

## 2. コンテナ

実装を始める前に、SongListオブジェクト内に曲のリストをどのように格納するかを考える必要があります。ここで考えられる選択肢は3つあります。RubyのArray型を使う、RubyのHash型を使う、または自分でリスト構造を作成するという方法です。今回は面倒なので、ArrayとHashを見てみて、どちらかをクラスに使うことにしましょう。

## 3. 配列

クラスArrayは、オブジェクトの参照のコレクションを保持します。各オブジェクトの参照は、配列内の位置を表す非負の整数インデックスによって識別されます。

配列は、リテラルを使用するか、明示的にArrayオブジェクトを作成して作成できます。リテラル配列は、単に角括弧内にオブジェクトを並べたものです。

a = [ 3.14159, "pie", 99 ]
a.type    # => Array
a.length  # => 3
a[0]      # => 3.14159
a[1]      # => "pie"
a[2]      # => 99
a[3]      # => nil

b = Array.new
b.type    # => Array
b.length  # => 0
b[0] = "second"
b[1] = "array"
b  # => ["second", "array"]

配列は[]演算子を使ってインデックス指定します。ほとんどのRubyの演算子と同様に、これは実際にはメソッド（Arrayクラス内）であり、サブクラスでオーバーライドすることができます。上記の例のように、配列のインデックスは0から始まります。単一の整数で配列をインデックス指定すると、その位置にあるオブジェクトが返されます。もしそこにオブジェクトがなければ、nilが返されます。負の整数でインデックス指定すると、配列の末尾からカウントされます。

a = [ 1, 3, 5, 7, 9 ]
a[-1]  # => 9
a[-2]  # => 7
a[-99] # => nil

また、配列は2つの数値（[start, count]）を使ってインデックス指定できます。これは、start位置からcount個のオブジェクトを参照する新しい配列を返します。

a = [ 1, 3, 5, 7, 9 ]
a[1, 3]  # => [3, 5, 7]
a[3, 1]  # => [7]
a[-3, 2] # => [5, 7]

最後に、範囲を使って配列をインデックス指定できます。範囲は2つまたは3つのドットで区切られた開始位置と終了位置で構成されます。2ドット形式は終了位置を含み、3ドット形式は終了位置を含みません。

a = [ 1, 3, 5, 7, 9 ]
a[1..3]  # => [3, 5, 7]
a[1...3] # => [3, 5]
a[3..3]  # => [7]
a[-3..-1] # => [5, 7, 9]

[]演算子には対応する[]=演算子があり、これを使って配列の要素を設定できます。単一の整数インデックスで使用すると、その位置の要素が右辺の値で置き換えられます。結果として空白ができた場合は、nilで埋められます。

a = [ 1, 3, 5, 7, 9 ]  # => [1, 3, 5, 7, 9]
a[1] = 'bat'  # => [1, "bat", 5, 7, 9]
a[-3] = 'cat' # => [1, "bat", "cat", 7, 9]
a[3] = [ 9, 8 ] # => [1, "bat", "cat", [9, 8], 9]
a[6] = 99 # => [1, "bat", "cat", [9, 8], 9, nil, 99]

インデックスが2つの数（開始位置と長さ）や範囲の場合、その位置にある要素が右辺の値で置き換えられます。長さがゼロの場合、右辺の値は開始位置の前に挿入され、要素は削除されません。右辺が配列の場合、その要素が置き換えに使用されます。右辺の要素数と元の配列の要素数が異なる場合でも、配列のサイズは自動的に調整されます。

a = [ 1, 3, 5, 7, 9 ]  # => [1, 3, 5, 7, 9]
a[2, 2] = 'cat'  # => [1, 3, "cat", 9]
a[2, 0] = 'dog'  # => [1, 3, "dog", "cat", 9]
a[1, 1] = [ 9, 8, 7 ]  # => [1, 9, 8, 7, "dog", "cat", 9]
a[0..3] = []  # => ["dog", "cat", 9]
a[5] = 99  # => ["dog", "cat", 9, nil, nil, 99]

配列には、スタック、セット、キュー、デキュー、FIFOとして扱うための便利なメソッドが多数あります。配列メソッドの完全なリストは278ページから始まります。

## 4. ハッシュ

ハッシュ（時々、連想配列や辞書とも呼ばれます）は、配列と似ており、オブジェクト参照のインデックス付き集合です。ただし、配列は整数でインデックスを指定するのに対し、ハッシュでは任意のタイプのオブジェクト（文字列、正規表現など）でインデックスを指定できます。ハッシュに値を格納する際、実際には2つのオブジェクト（キーと値）を提供します。その後、同じキーを使ってハッシュから値を取得することができます。ハッシュの値は、任意のタイプのオブジェクトであっても構いません。

次の例では、ハッシュリテラルを使用しています。これは、波括弧内に「キー => 値」のペアを並べたものです。

h = { 'dog' => 'canine', 'cat' => 'feline', 'donkey' => 'asinine' }
h.length   # => 3
h['dog']   # => "canine"
h['cow'] = 'bovine'
h[12] = 'dodecine'
h['cat'] = 99
h   # => {"cow"=>"bovine", "cat"=>99, 12=>"dodecine", "donkey"=>"asinine", "dog"=>"canine"}

配列と比較して、ハッシュには一つの大きな利点があります。それは、任意のオブジェクトをインデックスとして使える点です。しかし、その反面、ハッシュには大きな欠点もあります。それは、要素が順序付けられていないため、ハッシュをスタックやキューとして簡単に使うことができない点です。

ハッシュは、Rubyで最も一般的に使用されるデータ構造の一つです。クラスHashによって実装されたメソッドの完全なリストは、317ページから始まります。


## 5. SongList コンテナの実装

配列とハッシュについて少し触れた後、いよいよジュークボックスの SongList を実装する準備が整いました。まず、SongList に必要な基本的なメソッドを考えてみましょう。今後追加することになるかもしれませんが、まずはこれで進めます。

append(aSong) » list
指定した曲をリストの末尾に追加します。

deleteFirst() » aSong
リストの先頭の曲を削除し、その曲を返します。

deleteLast() » aSong
リストの末尾の曲を削除し、その曲を返します。

[anIndex] » aSong
指定したインデックス（整数インデックスまたは曲のタイトル）で識別される曲を返します。


このリストを見て、実装の手がかりが得られます。末尾に曲を追加し、先頭と末尾から削除する能力は、ダブルエンドキュー（dequeue）― 両端キューを使うことを示唆しています。これは配列を使って実装できることがわかります。同様に、リスト内の特定の位置にある曲を返す能力も配列でサポートされています。

しかし、曲をタイトルで検索する必要もあり、これにはハッシュを使うことが考えられます。タイトルをキー、曲を値として扱います。ハッシュを使うことは可能でしょうか？ まあ、可能ではありますが、問題もあります。まず、ハッシュは順序付けされていないため、リストを追跡するために補助的な配列が必要になりそうです。さらに大きな問題は、ハッシュは同じ値に対して複数のキーをサポートしないことです。これが私たちのプレイリストでは問題になります。同じ曲が複数回再生リストに並ぶ可能性があるからです。したがって、現時点では曲を配列で管理し、タイトルで検索することにします。この部分がパフォーマンスのボトルネックになれば、後でハッシュベースの検索方法を追加できます。

まず、基本的な initialize メソッドでクラスを作成し、曲を保持するための配列を作り、その参照をインスタンス変数 @songs に格納します。

class SongList
  def initialize
    @songs = Array.new
  end
end

次に、SongList#append メソッドを実装します。指定された曲を @songs 配列の末尾に追加し、self（現在の SongList オブジェクトの参照）を返します。この self を返すことによって、複数の append メソッドを連続して呼び出すことができる便利な慣習を実現しています。後で例を見ていきます。

class SongList
  def append(aSong)
    @songs.push(aSong)
    self
  end
end

次に、deleteFirst と deleteLast メソッドを追加します。これらはそれぞれ、Array#shift と Array#pop を使って簡単に実装できます。

class SongList
  def deleteFirst
    @songs.shift
  end
  def deleteLast
    @songs.pop
  end
end

ここで、簡単なテストを行います。まず、4曲をリストに追加します。追加する際に、append が SongList オブジェクトを返すことを利用して、メソッド呼び出しをチェーンします。

list = SongList.new
list.
  append(Song.new('title1', 'artist1', 1)).
  append(Song.new('title2', 'artist2', 2)).
  append(Song.new('title3', 'artist3', 3)).
  append(Song.new('title4', 'artist4', 4))

次に、リストの先頭と末尾から曲が正しく削除され、リストが空になると nil が返されることを確認します。

list.deleteFirst  # => Song: title1--artist1 (1)
list.deleteFirst  # => Song: title2--artist2 (2)
list.deleteLast   # => Song: title4--artist4 (4)
list.deleteLast   # => Song: title3--artist3 (3)
list.deleteLast   # => nil

順調に進んでいます。次のメソッドは [] で、インデックスで要素にアクセスします。インデックスが数値であれば、その位置にある要素を返します。

class SongList
  def [](key)
    if key.kind_of?(Integer)
      @songs[key]
    else
      # ...
    end
  end
end

これをテストすると、次のようになります。

list[0]  # => Song: title1--artist1 (1)
list[2]  # => Song: title3--artist3 (3)
list[9]  # => nil

最後に、タイトルで曲を検索できる機能を追加します。これには、リスト内の各曲をスキャンし、タイトルをチェックする必要があります。そのために、Rubyの非常に便利な機能であるイテレーターを使う方法を学ぶ必要があります。

## 6. ブロックとイテレーター

次に、SongList の [] メソッドで、文字列を受け取り、そのタイトルを持つ曲を検索するコードを実装する必要があります。これは簡単に思えます。曲の配列があるので、それを一つずつ調べて一致するものを探すだけです。

class SongList
  def [](key)
    if key.kind_of?(Integer)
      return @songs[key]
    else
      for i in 0...@songs.length
        return @songs[i] if key == @songs[i].name
      end
    end
    return nil
  end
end

これで動作しますし、見た目にも馴染みがあります：配列を反復処理する for ループです。これ以上自然な方法はないように見えます。

しかし、実はもっと自然な方法があることがわかります。実際、私たちの for ループは配列と過度に親密です。配列の長さを求めて、値を順番に取得し、見つかるまで調べています。では、配列に対して各要素にテストを適用するよう頼む方法にしてみましょう。それがまさに Array の find メソッドの役割です。

class SongList
  def [](key)
    if key.kind_of?(Integer)
      result = @songs[key]
    else
      result = @songs.find { |aSong| key == aSong.name }
    end
    return result
  end
end

さらに、コードを短くするために、if を修飾子として使うことができます。

class SongList
  def [](key)
    return @songs[key] if key.kind_of?(Integer)
    return @songs.find { |aSong| aSong.name == key }
  end
end

find メソッドはイテレーターです――コードのブロックを繰り返し実行するメソッドです。イテレーターとコードブロックは Ruby の中でも非常に興味深い特徴の一つなので、しばらくこれについて詳しく見ていきましょう（その過程で、[] メソッド内のそのコード行が実際に何をしているのかも明らかになるでしょう）。


## 7. イテレーターの実装

Rubyのイテレーターは、単にコードのブロックを呼び出すことができるメソッドです。一見すると、RubyのブロックはC、Java、Perlのブロックと似ているように見えます。しかし、実際には、Rubyのブロックは、従来の方法で文をグループ化する方法ではありません。

まず、ブロックはメソッド呼び出しの直後にしか登場しません。ブロックは、メソッドの最後の引数と同じ行に書かれます。次に、ブロック内のコードは、それに遭遇したときには実行されません。代わりに、Rubyはブロックが現れる文脈（ローカル変数や現在のオブジェクトなど）を記憶し、メソッドに入ります。これが魔法の始まりです。

メソッド内では、yield 文を使って、ほぼメソッドのようにブロックを呼び出すことができます。yield が実行されるたびに、それはブロック内のコードを呼び出します。ブロックが終了すると、制御は yield の後に戻ります。[プログラミング言語愛好者は、yield というキーワードがLiskovの言語CLUのyield 関数を反映していることに喜ぶかもしれません。この言語は20年以上前に作られたもので、現在でも広く使われていない特徴を持っています。]

まずは、簡単な例を見てみましょう。

def threeTimes
  yield
  yield
  yield
end
threeTimes { puts "Hello" }

出力：

Hello
Hello
Hello

ブロック（波括弧で囲まれたコード）は、threeTimes メソッドの呼び出しに関連付けられています。このメソッド内では、yield が3回連続して呼ばれます。毎回、ブロック内のコードが実行され、元気な挨拶が表示されます。ブロックが面白いのは、そこにパラメータを渡したり、値を返したりできる点です。

例えば、指定した値までのフィボナッチ数列を返す簡単な関数を作成することができます。[基本的なフィボナッチ数列は、最初に2つの1があり、その後は前の2つの数の合計が続く整数の列です。フィボナッチ数列は、ソートアルゴリズムや自然現象の分析などで使われることがあります。]

def fibUpTo(max)
  i1, i2 = 1, 1        # 並列代入
  while i1 <= max
    yield i1
    i1, i2 = i2, i1+i2
  end
end
fibUpTo(1000) { |f| print f, " " }

出力：

1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987

この例では、yield 文にパラメータがあります。この値が関連するブロックに渡されます。ブロックの定義内では、引数リストが縦棒で囲まれています。この場合、変数 f はyieldで渡された値を受け取るので、ブロックは数列の各メンバーを表示します。（この例では並列代入も使用しています。これについてはページ75で詳しく説明します。）ブロックに渡すのは1つの値が一般的ですが、これは必須ではなく、ブロックには任意の数の引数を持たせることができます。

もしブロックに与えられるパラメータの数とyieldで渡す数が異なる場合、並列代入のルールが適用されます（少し工夫が加わっていて、yieldに複数のパラメータを渡すと、ブロックに1つの引数がある場合、それらは配列として渡されます）。

ブロックの引数には、既存のローカル変数を使うこともできます。この場合、変数の新しい値はブロックが終了した後も保持されます。予期しない動作を引き起こすこともありますが、既存の変数を使うことでパフォーマンスの向上も得られます。[これについての詳細やその他の「ハマりどころ」については、ページ127のリストを参照してください。パフォーマンスに関する情報はページ128から始まります。]

ブロックはメソッドに値を返すこともできます。ブロックで最後に評価された式の値が、yield の値としてメソッドに返されます。これが、Array クラスで使われる find メソッドの仕組みです。[find メソッドは実際にはEnumerableモジュールで定義されており、このモジュールはArrayクラスにミックスインされています。] その実装は次のようになるでしょう。

class Array
  def find
    for i in 0...size
      value = self[i]
      return value if yield(value)
    end
    return nil
  end
end

[1, 3, 5, 7, 9].find {|v| v*v > 30 }  # => 7

これは、配列の各要素を関連付けられたブロックに渡します。もしブロックがtrueを返すなら、メソッドはその要素を返します。もし一致する要素がなければ、nilを返します。この例では、イテレーターのアプローチの利点がよく分かります。Arrayクラスは最も得意な配列の要素へのアクセスを行い、アプリケーションコードは特定の要求（この場合、数学的な基準を満たすエントリを見つけること）に集中することができます。

多くの種類のRubyコレクションには共通のイテレーターがあります。すでにfindを見ましたが、他にも each と collect があります。each はおそらく最もシンプルなイテレーターで、単にコレクションの各要素をブロックに渡します。

[1, 3, 5].each { |i| puts i }

出力：

1
3
5

each イテレーターはRubyにおいて特別な位置を占めています；ページ85では、Rubyの for ループの基盤として each がどのように使われているかを説明し、ページ102からは、each メソッドを定義することでクラスに多くの機能を無料で追加する方法を見ていきます。

もう1つの一般的なイテレーターは collect で、コレクションの各要素を取り出してブロックに渡します。ブロックが返した結果は、新しい配列を作成するために使われます。例えば：

["H", "A", "L"].collect { |x| x.succ }

出力：

["I", "B", "M"]

## 8. Ruby と C++、Java の比較

Ruby のイテレータのアプローチは、C++ や Java のそれとは異なります。Ruby のアプローチでは、イテレータは単に他のメソッドと同じであり、値を生成するたびに yield を呼び出すという特徴があります。このイテレータを使うのは、このメソッドに関連付けられたコードブロックです。Java や C++ のようにイテレータの状態を保持するために補助クラスを生成する必要はありません。この点においても、Ruby は透明な言語です。Ruby プログラムを書くとき、言語自体をサポートするための足場を作ることに集中するのではなく、実際に仕事を達成することに集中できます。

イテレータは、配列やハッシュ内の既存のデータをアクセスすることに限りません。フィボナッチの例で見たように、イテレータは派生した値を返すことができます。この機能は、Ruby の入出力クラスによって使用されており、これらは I/O ストリーム内の次々に出てくる行（またはバイト）を返すイテレータインターフェースを実装しています。

f = File.open("testfile")
f.each do |line|
  print line
end
f.close

このコードの出力は次のようになります：

This is line one
This is line two
This is line three
...

次に、もう一つのイテレータの実装を見てみましょう。Smalltalk 言語もコレクションに対するイテレータをサポートしています。Smalltalk のプログラマーに配列の要素を合計するように頼むと、inject 関数を使うことが多いです。

sumOfValues              "Smalltalk method"
    ^self values
          inject: 0
          into: [ :sum :element | sum + element value]

inject はこのように動作します。関連するブロックが初めて呼び出されるとき、sum は inject の引数（この場合は 0）に設定され、element は配列の最初の要素に設定されます。2 回目以降、このブロックが呼び出されるとき、sum は前回ブロックで返された値に設定されます。こうして sum は累積合計を保持することができます。inject の最終的な値は、ブロックが最後に呼び出されたときに返された値です。

Ruby には inject メソッドはありませんが、簡単に自分で書くことができます。以下に、Array クラスに inject メソッドを追加する方法を示します。また、次のページではもっと一般的に利用できるようにする方法を見ていきます。

class Array
  def inject(n)
     each { |value| n = yield(n, value) }
     n
  end
  def sum
    inject(0) { |n, value| n + value }
  end
  def product
    inject(1) { |n, value| n * value }
  end
end

次のコードの出力は以下のようになります：

[ 1, 2, 3, 4, 5 ].sum     # => 15
[ 1, 2, 3, 4, 5 ].product # => 120

ブロックはイテレータのターゲットであることが多いですが、他にもさまざまな用途があります。

## 9. トランザクションのためのブロック

ブロックは、ある種のトランザクション管理のもとで実行する必要があるコードの塊を定義するために使用できます。たとえば、ファイルを開いてその内容を処理し、その後ファイルを閉じる必要がある場合に便利です。通常のコードでもこれを行うことができますが、ファイル自身に閉じる責任を持たせるという考え方もあります。これをブロックを使って実現できます。エラーハンドリングを無視した単純な実装は次のようになります。

class File
  def File.openAndProcess(*args)
    f = File.open(*args)
    yield f
    f.close()
  end
end

File.openAndProcess("testfile", "r") do |aFile|
  print while aFile.gets
end

このコードの出力は次のようになります：

This is line one
This is line two
This is line three
...

この小さな例ではいくつかの技法が示されています。openAndProcess メソッドはクラスメソッドです ― つまり、特定の File オブジェクトとは独立して呼び出すことができます。このメソッドは、従来の File.open メソッドと同じ引数を取りますが、その引数が何であるかにはあまり関心がありません。代わりに引数を *args として指定することで、「実際にメソッドに渡された引数を配列として収集する」という意味になります。次に、File.open を呼び出し、*args を引数として渡します。これにより、配列が個々の引数に展開されます。結果として、openAndProcess は、受け取った引数を透明に File.open に渡します。

ファイルが開かれた後、openAndProcess は yield を呼び出し、開いたファイルオブジェクトをブロックに渡します。ブロックが終了すると、ファイルが閉じられます。このようにして、ファイルを閉じる責任はファイルのユーザーからファイル自体に移されます。

最後に、この例では do...end を使ってブロックを定義しています。この表記とブレース {...} を使ってブロックを定義する違いは、優先順位にあります：do...end は {...} よりも優先順位が低いです。この違いがどのように影響するかについては、234ページで説明します。

ファイルが自分自身のライフサイクルを管理するという技法は非常に便利であり、Ruby の File クラスはこれを直接サポートしています。もし File.open に関連するブロックが渡されていれば、そのブロックはファイルオブジェクトを受け取り、ブロックが終了したときにファイルは閉じられます。これは興味深い点で、File.open には2つの異なる動作があることを意味します：ブロックが渡されると、ブロックを実行してファイルを閉じます。ブロックが渡されないと、ファイルオブジェクトを返します。この動作は Kernel::block_given? メソッドによって実現されています。このメソッドは、現在のメソッドにブロックが関連付けられている場合に true を返します。これを使用して、次のように File.open を実装することができます（エラーハンドリングは無視しています）。

class File
  def File.myOpen(*args)
    aFile = File.new(*args)
    # ブロックが渡されていれば、ファイルを渡し、ブロック終了時にファイルを閉じる
    if block_given?
      yield aFile
      aFile.close
      aFile = nil
    end
    return aFile
  end
end


##  10. ブロックはクロージャにもなり得る

少し前に戻って、ジュークボックスのコードを考えてみましょう（ジュークボックスのことを覚えていますか？）。ある時点で、ユーザーインターフェースを処理するコードに取り組むことになります――つまり、ユーザーが押すボタン（曲の選択やジュークボックスの制御）のことです。そのボタンにアクションを関連付ける必要があります。例えば、STOPボタンが押されれば音楽が止まるといった具合です。Rubyのブロックは、このような処理に非常に便利です。まずは、ハードウェアの製造元がRubyの拡張機能を実装して、基本的なボタンクラスを提供してくれたと仮定しましょう。（Rubyの拡張については169ページから説明しています。）

bStart = Button.new("Start")
bPause = Button.new("Pause")
# ...

では、ユーザーがボタンを押したとき、何が起こるのでしょうか？ Button クラスでは、ハードウェアの担当者がボタンが押された際に buttonPressed というコールバックメソッドを呼び出すように仕組まれています。このボタンに機能を追加する最も明白な方法は、Button を継承したサブクラスを作り、そのサブクラスで独自の buttonPressed メソッドを実装することです。

class StartButton < Button
  def initialize
    super("Start")       # Buttonのinitializeを呼び出す
  end
  def buttonPressed
    # スタートアクションを実行...
  end
end

bStart = StartButton.new

ここには二つの問題があります。まず第一に、これではサブクラスが大量に作られることになります。もし Button インターフェースが変更されれば、私たちがメンテナンスしなければならないことが増えるかもしれません。第二に、ボタンが押されたときに実行されるアクションはボタンの特徴ではなく、ボタンを使うジュークボックスの特徴であるべきです。この問題を解決するために、ブロックを使うことができます。

class JukeboxButton < Button
  def initialize(label, &action)
    super(label)
    @action = action
  end
  def buttonPressed
    @action.call(self)
  end
end

bStart = JukeboxButton.new("Start") { songList.start }
bPause = JukeboxButton.new("Pause") { songList.pause }

ここで重要なのは、JukeboxButton#initialize の第二引数です。メソッド定義で最後の引数にアンパサンド（&）を付けると、そのメソッドが呼ばれるときにブロックを探し、そのブロックをProcオブジェクトに変換して引数に渡します。これにより、ブロックは他の変数と同様に扱うことができます。この例では、ブロックをインスタンス変数 @action に代入しています。buttonPressed というコールバックメソッドが呼ばれると、Proc#call メソッドを使ってそのブロックを実行します。

では、Procオブジェクトを作成したときに正確に何が得られるのでしょうか？興味深いのは、Procオブジェクトが単なるコードの塊以上のものであるという点です。ブロック（したがってProcオブジェクト）には、そのブロックが定義された時のコンテキスト（self の値、メソッド、変数、定数など）が関連付けられています。Rubyの魔法の一部は、ブロックが定義された環境が消えたとしても、その元々のスコープ情報をブロックが使い続けられるところにあります。他の言語では、これを「クロージャ」と呼びます。

次に、少し作り込んだ例を見てみましょう。この例では、proc メソッドを使ってブロックをProcオブジェクトに変換します。

def nTimes(aThing)
  return proc { |n| aThing * n }
end
p1 = nTimes(23)
p1.call(3)	# => 69
p1.call(4)	# => 92
p2 = nTimes("Hello ")
p2.call(3)	# => "Hello Hello Hello "

nTimes メソッドは、aThing パラメータを参照するProcオブジェクトを返します。ブロックが呼ばれる時点では、そのパラメータはスコープ外にありますが、それでもブロック内からそのパラメータにアクセスすることができます。

