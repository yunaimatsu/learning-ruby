## 1. 導入

これまでの例を見て、Rubyがオブジェクト指向言語だという主張について疑問に思っているかもしれません。さて、この章ではその主張をどのように証明するかについて説明します。Rubyでクラスとオブジェクトを作成する方法や、Rubyが多くのオブジェクト指向言語よりも強力である点について見ていきます。その過程で、次の億ドル製品「インターネット対応ジャズ＆ブルーグラスジュークボックス」の一部を実装していきます。

数ヶ月にわたる作業の結果、我々の高給取りの研究開発チームは、ジュークボックスには曲が必要だと結論しました。そこで、まずは「曲」を表すRubyのクラスを作成するのが良い考えだとわかりました。実際の曲には名前、アーティスト、再生時間があるので、プログラム内の曲オブジェクトにもそれらを持たせる必要があります。

まずは基本的なクラスSongを作成し、単一のメソッドinitializeだけを含めてみます。

```rb
class Song
  def initialize(name, artist, duration)
    @name     = name
    @artist   = artist
    @duration = duration
  end
end
```

initializeはRubyプログラムで特別なメソッドです。Song.newを呼び出して新しいSongオブジェクトを作成すると、Rubyは初期化されていないオブジェクトを作成し、そのオブジェクトのinitializeメソッドを呼び出します。この際、newに渡された引数がinitializeメソッドに渡されます。これにより、オブジェクトの状態を設定するためのコードを書くことができます。

Songクラスの場合、initializeメソッドは3つのパラメータを受け取ります。これらのパラメータはメソッド内でローカル変数のように扱われ、ローカル変数の命名規則に従い、小文字で始まります。

各オブジェクトはそれぞれ独自の曲を表しているので、Songオブジェクトごとに名前、アーティスト、再生時間を保持する必要があります。これには、オブジェクト内でインスタンス変数としてこれらの値を保存します。Rubyではインスタンス変数は名前の前に「@」を付けるだけで表現できます。例えば、パラメータnameはインスタンス変数@nameに、artistは@artistに、durationは@durationにそれぞれ割り当てられます。

では、この新しいクラスをテストしてみましょう。

```rb
aSong = Song.new("Bicylops", "Fleck", 260)
aSong.inspect  # => "#<Song:0x401b4924 @duration=260, @artist=\"Fleck\", @name=\"Bicylops\">"
```

うまくいったようです。デフォルトで、inspectメッセージは任意のオブジェクトに送信でき、オブジェクトのIDとインスタンス変数が表示されます。インスタンス変数が正しく設定されていることがわかります。

私たちの経験から、開発中にSongオブジェクトの内容を何度も印刷することになるでしょうが、inspectのデフォルトフォーマットはあまり便利ではありません。幸い、Rubyにはすべてのオブジェクトに対して文字列として表示されるto_sという標準メソッドがあります。これを曲に試してみましょう。

aSong = Song.new("Bicylops", "Fleck", 260)
aSong.to_s  # => "#<Song:0x401b499c>"

あまり役に立ちませんでしたね—オブジェクトIDだけが表示されました。そこで、to_sメソッドをクラス内でオーバーライドしてみましょう。この機会に、私たちがこの本でどのようにクラス定義を示しているかについても触れておきましょう。

Rubyでは、クラスは決して閉じられることはありません。既存のクラスに新しいメソッドを追加することができます。これには、自分で作成したクラスだけでなく、標準の組み込みクラスも含まれます。既存のクラス定義を開くことで、新しい内容がそのクラスに追加されます。

これは私たちにとって非常に便利です。この章を通して、クラスに機能を追加していく過程で、新しいメソッドだけをクラス定義として示し、古いものはそのままにしておきます。これにより、各例で冗長なコードを繰り返す必要がなくなります。もちろん、もしこのコードを最初から作成するのであれば、すべてのメソッドを一つのクラス定義内に書くことになるでしょう。

さて、詳細はここまでにして、Songクラスにto_sメソッドを追加しましょう。

class Song
  def to_s
    "Song: #{@name}--#{@artist} (#{@duration})"
  end
end

aSong = Song.new("Bicylops", "Fleck", 260)
aSong.to_s  # => "Song: Bicylops--Fleck (260)"

素晴らしい、進展があります。しかし、ここで少し微妙な点を見落としました。Rubyがすべてのオブジェクトにto_sをサポートしていると述べましたが、その仕組みについては説明していませんでした。その答えは、継承、サブクラス化、そしてRubyがオブジェクトにメッセージを送る際にどのメソッドを実行するかをどのように決定するかに関係しています。これは次のセクションで扱う内容です。

## 2. 継承とメッセージ

継承を使うと、別のクラスを基にして、新しいクラスを作成することができます。例えば、私たちのジュークボックスには「曲」という概念があり、これをSongクラスで表現しています。そこにマーケティング担当者がやってきて、カラオケ機能を追加するように言われました。カラオケの曲は、他の曲とほとんど同じですが（歌声は入っていませんが、それは問題ではありません）、歌詞とタイミング情報を持っています。ジュークボックスがカラオケ曲を再生するとき、歌詞は曲の進行に合わせてジュークボックスの画面に流れる必要があります。

この問題に対処するためには、新しいクラスKaraokeSongを定義します。KaraokeSongはSongとほとんど同じですが、歌詞トラックを追加します。

class KaraokeSong < Song
  def initialize(name, artist, duration, lyrics)
    super(name, artist, duration)
    @lyrics = lyrics
  end
end

< Songというクラス定義の行は、KaraokeSongがSongのサブクラスであることをRubyに伝えます。（予想通り、これによりSongはKaraokeSongの親クラスになります。人々はこれを親子関係と呼ぶこともあります。）今のところ、initializeメソッドについては心配しないでください。superの使い方については後で説明します。

それでは、KaraokeSongを作成して、コードが動作するか確認してみましょう。（最終システムでは、歌詞はテキストとタイミング情報を含むオブジェクトに格納されますが、ここでは単に文字列を使ってテストします。これは型がない言語のもう一つの利点です---コードを実行し始める前にすべてを定義する必要はありません。）

aSong = KaraokeSong.new("My Way", "Sinatra", 225, "And now, the...")
aSong.to_s  # => "Song: My Way--Sinatra (225)"

実行はできましたが、なぜto_sメソッドに歌詞が表示されないのでしょうか？

その答えは、Rubyがメッセージがオブジェクトに送られたときに、どのメソッドを呼び出すべきかをどのように決定するかに関係しています。RubyがaSong.to_sというメソッド呼び出しをコンパイルするとき、実際にはto_sメソッドがどこにあるかはわかりません。そのため、プログラムが実行されるまで決定を遅延させます。そのとき、RubyはaSongのクラスを見て、そのクラスがメッセージと同じ名前のメソッドを実装していれば、そのメソッドを実行します。もし見つからなければ、Rubyは親クラス、さらに親クラスを遡って探します。もし適切なメソッドが見つからなければ、特別な処理が行われ、通常はエラーが発生します。

では、私たちの例に戻りましょう。to_sメソッドをaSongというKaraokeSongクラスのオブジェクトに送ったところ、RubyはKaraokeSongクラス内でto_sメソッドを見つけられませんでした。そのため、RubyはKaraokeSongの親であるSongクラスを調べ、そこに私たちがページ18で定義したto_sメソッドを見つけたのです。だから、歌詞が表示されないのです。Songクラスは歌詞について何も知りません。

class KaraokeSong
  # ...
  def to_s
    "KS: #{@name}--#{@artist} (#{@duration}) [#{@lyrics}]"
  end
end

再度テストしてみましょう。

aSong = KaraokeSong.new("My Way", "Sinatra", 225, "And now, the...")
aSong.to_s  # => "KS: My Way--Sinatra (225) [And now, the...]"

これで、@lyricsインスタンス変数の値が正しく表示されるようになりました。しかし、この実装には問題があります。なぜなら、親クラスの内部状態に直接アクセスしているからです。これにより、親クラスの実装に強く依存することになります。例えば、もしSongクラスを変更して曲の長さをミリ秒単位で保存するようにした場合、KaraokeSongは突飛な値を表示することになってしまいます。たとえば、「『My Way』のカラオケバージョンが3750分も続く」というのはあまりにも怖すぎます。

この問題を回避するために、各クラスは自分の内部状態を管理します。KaraokeSong#to_sが呼ばれると、まず親のto_sメソッドを呼び出して曲の詳細を取得し、それに歌詞情報を追加して結果を返すようにします。ここで使うのがRubyのsuperキーワードです。superを引数なしで呼び出すと、Rubyは現在のオブジェクトの親にメッセージを送り、親の同名のメソッドを呼び出します。その際、現在のメソッドに渡された引数も親に渡されます。

それでは、新しいto_sメソッドを実装してみましょう。

class KaraokeSong < Song
  # 自分を文字列としてフォーマットするために
  # 親の#to_sの値に歌詞を追加します。
  def to_s
    super + " [#{@lyrics}]"
  end
end

再度テストしてみます。

aSong = KaraokeSong.new("My Way", "Sinatra", 225, "And now, the...")
aSong.to_s  # => "Song: My Way--Sinatra (225) [And now, the...]"

これで、歌詞が正しく表示されるようになりました。また、Songクラスに親クラスが明示的に指定されていませんが、Songクラスは暗黙のうちにObjectクラスを親として持っています。これにより、すべてのオブジェクトはObjectクラスを祖先として持ち、そのインスタンスメソッドはすべてのオブジェクトで利用可能です。to_sもその一例で、Objectクラスに35以上のインスタンスメソッドが定義されています。

## 3. 継承とミックスイン

一部のオブジェクト指向プログラミング言語（特にC++）では、複数の親を持つことができる「多重継承」がサポートされています。この技法は強力ですが、継承の階層が曖昧になる可能性があるため、危険な場合もあります。

Javaのような言語では、単一継承がサポートされています。ここでは、クラスは1つの親クラスしか持つことができません。単一継承はよりクリーンで実装が簡単ですが、現実世界では物事が複数のソースから属性を引き継ぐことが多いため（例えば、ボールは「バウンスするもの」でも「球形のもの」でもあります）、その欠点もあります。

Rubyは、単一継承のシンプルさと多重継承の力を兼ね備えた面白くて強力な妥協策を提供します。Rubyクラスは1つの直接の親クラスしか持つことができません。したがって、Rubyは単一継承の言語です。しかし、Rubyクラスは任意の数のミックスインを含むことができ、これが多重継承のような能力を提供します。この方法には多重継承の欠点がないため、制御された多重継承のような機能を提供します。ミックスインについては、98ページから詳しく説明します。

> ✍ミクシンのページさがす

これまでの章ではクラスとそのメソッドを見てきましたが、ここでは実際のオブジェクト、例えば Song クラスのインスタンスについて見ていきます。

> ✍ここまではクラス自体、ここからはインスタンス

## 4. オブジェクトと属性

これまでに作成した Song オブジェクトには、内部状態（例えば、曲のタイトルやアーティスト）が含まれています。その状態はオブジェクトに対してプライベートであり、他のオブジェクトはオブジェクトのインスタンス変数にアクセスできません。一般的に、これは良いことです。なぜなら、それによってオブジェクト自身がその整合性を保つ責任を持つからです。

しかし、完全に秘密主義なオブジェクトはあまり役に立ちません。オブジェクトを作成できても、その後何もできないからです。通常、オブジェクトの状態にアクセスしたり操作したりするためのメソッドを定義します。これにより、外部の世界がオブジェクトとやり取りできるようになります。これらの外部から見えるオブジェクトの側面は、その「属性」と呼ばれます。

私たちの Song オブジェクトの場合、最初に必要なのは、曲名やアーティストを取得する機能（再生中に表示できるように）と、曲の長さを取得する機能（進行バーを表示できるように）です。

class Song
  def name
    @name
  end
  def artist
    @artist
  end
  def duration
    @duration
  end
end

aSong = Song.new("Bicylops", "Fleck", 260)
aSong.artist  # => "Fleck"
aSong.name    # => "Bicylops"
aSong.duration  # => 260

ここでは、3つのアクセサーメソッドを定義して、3つのインスタンス属性の値を返しています。これは非常に一般的な手法なので、Rubyでは便利なショートカットを提供しています：attr_reader は、これらのアクセサーメソッドを自動的に作成してくれます。

class Song
  attr_reader :name, :artist, :duration
end

aSong = Song.new("Bicylops", "Fleck", 260)
aSong.artist  # => "Fleck"
aSong.name    # => "Bicylops"
aSong.duration  # => 260

この例では新しいものが登場しています。:artist という構文は、artist に対応する Symbol オブジェクトを返す式です。:artist は変数 artist の名前を意味し、artist はその変数の値を意味します。この例では、アクセサーメソッドを name、artist、duration と名付けました。対応するインスタンス変数 @name、@artist、@duration は自動的に作成されます。これらのアクセサーメソッドは、先に手動で書いたものと全く同じです。

## 5. 書き込み可能な属性

時には、オブジェクトの外部から属性を設定できるようにする必要があります。例えば、曲に最初に関連付けられた再生時間が予測値であると仮定しましょう（例えば、CD情報やMP3データから取得したもの）。曲を初めて再生するときに実際の再生時間を知り、その新しい値をSongオブジェクトに保存します。

C++やJavaなどの言語では、これをセッター関数で行います。

class JavaSong {                     // Javaのコード
  private Duration myDuration;
  public void setDuration(Duration newDuration) {
    myDuration = newDuration;
  }
}
s = new Song(....)
s.setDuration(length)

Rubyでは、オブジェクトの属性は他の変数のようにアクセスできます。先ほど見たように、aSong.name というフレーズがその例です。したがって、属性の値を設定したいときにこれらの変数に代入できるのは自然なことです。Rubyでは、これはその通りに動作します（予期しない挙動を避ける原則に従っています）。

class Song
  def duration=(newDuration)
    @duration = newDuration
  end
end
aSong = Song.new("Bicylops", "Fleck", 260)
aSong.duration  # => 260
aSong.duration = 257   # 属性に新しい値を設定
aSong.duration  # => 257

aSong.duration = 257 という代入は、aSong オブジェクト内の duration= メソッドを呼び出し、257を引数として渡しています。実際、= で終わるメソッド名を定義することで、そのメソッド名が代入の左辺に現れることができるようになります。

再び、Rubyではこれらのシンプルな属性設定メソッドを作成するためのショートカットを提供しています。

class Song
  attr_writer :duration
end
aSong = Song.new("Bicylops", "Fleck", 260)
aSong.duration = 257


## 6. 仮想属性

これらの属性アクセサメソッドは、単にオブジェクトのインスタンス変数をラップするだけのものではありません。例えば、これまで秒単位で扱っていた再生時間を、分単位や分の小数点部分でアクセスしたい場合があります。

class Song
  def durationInMinutes
    @duration / 60.0   # 浮動小数点に強制変換
  end

  def durationInMinutes=(value)
    @duration = (value * 60).to_i
  end
end

aSong = Song.new("Bicylops", "Fleck", 260)
aSong.durationInMinutes  # => 4.333333333
aSong.durationInMinutes = 4.2
aSong.duration  # => 252

ここでは、属性メソッドを使って仮想的なインスタンス変数を作成しています。外部から見ると、durationInMinutes は他の属性と同じように見えます。しかし、内部的にはそれに対応するインスタンス変数は存在しません。

これは単なる好奇心からの例ではありません。ベルナール・メイヤーの著書『オブジェクト指向ソフトウェア構築』において、彼はこれを「均一アクセス原則（Uniform Access Principle）」と呼んでいます。インスタンス変数と計算された値の違いを隠すことで、クラスの実装を他の世界から隔離できます。これにより、将来的に実装を変更しても、そのクラスを使用している何百万行ものコードに影響を与えることなく、クラスの使い方に変更を加えることができます。これは大きな利点です。


## 7. クラス変数とクラスメソッド

これまで作成したクラスはすべてインスタンス変数とインスタンスメソッドを含んでいました。インスタンス変数はクラスの特定のインスタンスに関連付けられた変数で、インスタンスメソッドはそれらの変数に対して動作します。しかし、時にはクラス自体が独自の状態を持つ必要があることがあります。これがクラス変数の出番です。


## 8. クラス変数

クラス変数は、クラスのすべてのオブジェクトで共有され、後で説明するクラスメソッドからもアクセスできます。特定のクラスに対してクラス変数は一つだけ存在します。クラス変数の名前は、@@countのように「@」を二つ並べて始まります。グローバル変数やインスタンス変数とは異なり、クラス変数は使用する前に初期化する必要があります。この初期化は、クラス定義の本体で単純な代入として行われることがよくあります。

例えば、私たちのジュークボックスが、各曲が再生された回数を記録したい場合を考えます。このカウントは、おそらくSongオブジェクトのインスタンス変数になります。曲が再生されるたびに、そのインスタンスの値が増加します。しかし、もし全曲の再生回数の合計を知りたい場合、すべてのSongオブジェクトを検索してそのカウントを合計するか、グローバル変数を使ってしまうリスクを冒すことになります。その代わりに、クラス変数を使うことができます。

class Song
  @@plays = 0
  def initialize(name, artist, duration)
    @name     = name
    @artist   = artist
    @duration = duration
    @plays    = 0
  end
  def play
    @plays += 1
    @@plays += 1
    "This song: #@plays plays. Total #@@plays plays."
  end
end

デバッグのために、Song#playがこの曲が再生された回数と、すべての曲の合計再生回数を含む文字列を返すようにしています。簡単にテストできます。

s1 = Song.new("Song1", "Artist1", 234)  # test songs..
s2 = Song.new("Song2", "Artist2", 345)
s1.play	# => "This song: 1 plays. Total 1 plays."
s2.play	# => "This song: 1 plays. Total 2 plays."
s1.play	# => "This song: 2 plays. Total 3 plays."
s1.play	# => "This song: 3 plays. Total 4 plays."

クラス変数はクラスとそのインスタンスに対してプライベートです。外部からアクセスできるようにしたい場合は、アクセサメソッドを作成する必要があります。このメソッドはインスタンスメソッドであっても、次のセクションに進むためにクラスメソッドであっても構いません。

## 9. クラスメソッド

時には、クラスが特定のオブジェクトに結びつかずに動作するメソッドを提供する必要があります。これまでに、newメソッドがその一例です。このメソッドは新しいSongオブジェクトを作成しますが、特定の曲に関連付けられているわけではありません。

aSong = Song.new(....)

Rubyのライブラリには、クラスメソッドが数多く存在します。例えば、Fileクラスのオブジェクトは、基盤となるファイルシステムで開かれているファイルを表します。しかし、Fileクラス自体には開かれていないファイルを操作するためのクラスメソッドもいくつかあります。ファイルを削除したい場合は、File.deleteというクラスメソッドを呼び出し、ファイル名を渡します。

File.delete("doomedFile")

クラスメソッドは、インスタンスメソッドとは定義方法が異なります。クラスメソッドは、メソッド名の前にクラス名とピリオドを置くことで定義されます。

class Example
  def instMeth              # インスタンスメソッド
  end

  def Example.classMeth     # クラスメソッド
  end
end

ジュークボックスは、曲ごとに料金を請求しますが、分単位ではなく曲単位で料金を設定します。これにより、短い曲の方が長い曲よりも収益性が高くなります。そこで、特定の曲が長すぎてSongListに追加できないようにするためのクラスメソッドをSongListに定義することができます。この制限を設定するために、クラス定数（大文字で始まる定数）をクラス内で初期化します。

class SongList
  MaxTime = 5*60           # 5分
  def SongList.isTooLong(aSong)
    return aSong.duration > MaxTime
  end
end

以下のように、Songオブジェクトを作成し、SongListクラスのクラスメソッドisTooLongを呼び出すことができます。

song1 = Song.new("Bicylops", "Fleck", 260)
SongList.isTooLong(song1)  # => false

song2 = Song.new("The Calling", "Santana", 468)
SongList.isTooLong(song2)



