## 1. 導入

これまでの例を見て、Rubyがオブジェクト指向言語だという主張について疑問に思っているかもしれません。さて、この章ではその主張をどのように証明するかについて説明します。Rubyでクラスとオブジェクトを作成する方法や、Rubyが多くのオブジェクト指向言語よりも強力である点について見ていきます。その過程で、次の億ドル製品「インターネット対応ジャズ＆ブルーグラスジュークボックス」の一部を実装していきます。

数ヶ月にわたる作業の結果、我々の高給取りの研究開発チームは、ジュークボックスには曲が必要だと結論しました。そこで、まずは「曲」を表すRubyのクラスを作成するのが良い考えだとわかりました。実際の曲には名前、アーティスト、再生時間があるので、プログラム内の曲オブジェクトにもそれらを持たせる必要があります。

まずは基本的なクラスSongを作成し、単一のメソッドinitializeだけを含めてみます。

class Song
  def initialize(name, artist, duration)
    @name     = name
    @artist   = artist
    @duration = duration
  end
end

initializeはRubyプログラムで特別なメソッドです。Song.newを呼び出して新しいSongオブジェクトを作成すると、Rubyは初期化されていないオブジェクトを作成し、そのオブジェクトのinitializeメソッドを呼び出します。この際、newに渡された引数がinitializeメソッドに渡されます。これにより、オブジェクトの状態を設定するためのコードを書くことができます。

Songクラスの場合、initializeメソッドは3つのパラメータを受け取ります。これらのパラメータはメソッド内でローカル変数のように扱われ、ローカル変数の命名規則に従い、小文字で始まります。

各オブジェクトはそれぞれ独自の曲を表しているので、Songオブジェクトごとに名前、アーティスト、再生時間を保持する必要があります。これには、オブジェクト内でインスタンス変数としてこれらの値を保存します。Rubyではインスタンス変数は名前の前に「@」を付けるだけで表現できます。例えば、パラメータnameはインスタンス変数@nameに、artistは@artistに、durationは@durationにそれぞれ割り当てられます。

では、この新しいクラスをテストしてみましょう。

aSong = Song.new("Bicylops", "Fleck", 260)
aSong.inspect  # => "#<Song:0x401b4924 @duration=260, @artist=\"Fleck\", @name=\"Bicylops\">"

うまくいったようです。デフォルトで、inspectメッセージは任意のオブジェクトに送信でき、オブジェクトのIDとインスタンス変数が表示されます。インスタンス変数が正しく設定されていることがわかります。

私たちの経験から、開発中にSongオブジェクトの内容を何度も印刷することになるでしょうが、inspectのデフォルトフォーマットはあまり便利ではありません。幸い、Rubyにはすべてのオブジェクトに対して文字列として表示されるto_sという標準メソッドがあります。これを曲に試してみましょう。

aSong = Song.new("Bicylops", "Fleck", 260)
aSong.to_s  # => "#<Song:0x401b499c>"

あまり役に立ちませんでしたね—オブジェクトIDだけが表示されました。そこで、to_sメソッドをクラス内でオーバーライドしてみましょう。この機会に、私たちがこの本でどのようにクラス定義を示しているかについても触れておきましょう。

Rubyでは、クラスは決して閉じられることはありません。既存のクラスに新しいメソッドを追加することができます。これには、自分で作成したクラスだけでなく、標準の組み込みクラスも含まれます。既存のクラス定義を開くことで、新しい内容がそのクラスに追加されます。

これは私たちにとって非常に便利です。この章を通して、クラスに機能を追加していく過程で、新しいメソッドだけをクラス定義として示し、古いものはそのままにしておきます。これにより、各例で冗長なコードを繰り返す必要がなくなります。もちろん、もしこのコードを最初から作成するのであれば、すべてのメソッドを一つのクラス定義内に書くことになるでしょう。

さて、詳細はここまでにして、Songクラスにto_sメソッドを追加しましょう。

class Song
  def to_s
    "Song: #{@name}--#{@artist} (#{@duration})"
  end
end

aSong = Song.new("Bicylops", "Fleck", 260)
aSong.to_s  # => "Song: Bicylops--Fleck (260)"

素晴らしい、進展があります。しかし、ここで少し微妙な点を見落としました。Rubyがすべてのオブジェクトにto_sをサポートしていると述べましたが、その仕組みについては説明していませんでした。その答えは、継承、サブクラス化、そしてRubyがオブジェクトにメッセージを送る際にどのメソッドを実行するかをどのように決定するかに関係しています。これは次のセクションで扱う内容です。

## 2. 継承とメッセージ

継承を使うと、別のクラスを基にして、新しいクラスを作成することができます。例えば、私たちのジュークボックスには「曲」という概念があり、これをSongクラスで表現しています。そこにマーケティング担当者がやってきて、カラオケ機能を追加するように言われました。カラオケの曲は、他の曲とほとんど同じですが（歌声は入っていませんが、それは問題ではありません）、歌詞とタイミング情報を持っています。ジュークボックスがカラオケ曲を再生するとき、歌詞は曲の進行に合わせてジュークボックスの画面に流れる必要があります。

この問題に対処するためには、新しいクラスKaraokeSongを定義します。KaraokeSongはSongとほとんど同じですが、歌詞トラックを追加します。

class KaraokeSong < Song
  def initialize(name, artist, duration, lyrics)
    super(name, artist, duration)
    @lyrics = lyrics
  end
end

< Songというクラス定義の行は、KaraokeSongがSongのサブクラスであることをRubyに伝えます。（予想通り、これによりSongはKaraokeSongの親クラスになります。人々はこれを親子関係と呼ぶこともあります。）今のところ、initializeメソッドについては心配しないでください。superの使い方については後で説明します。

それでは、KaraokeSongを作成して、コードが動作するか確認してみましょう。（最終システムでは、歌詞はテキストとタイミング情報を含むオブジェクトに格納されますが、ここでは単に文字列を使ってテストします。これは型がない言語のもう一つの利点です---コードを実行し始める前にすべてを定義する必要はありません。）

aSong = KaraokeSong.new("My Way", "Sinatra", 225, "And now, the...")
aSong.to_s  # => "Song: My Way--Sinatra (225)"

実行はできましたが、なぜto_sメソッドに歌詞が表示されないのでしょうか？

その答えは、Rubyがメッセージがオブジェクトに送られたときに、どのメソッドを呼び出すべきかをどのように決定するかに関係しています。RubyがaSong.to_sというメソッド呼び出しをコンパイルするとき、実際にはto_sメソッドがどこにあるかはわかりません。そのため、プログラムが実行されるまで決定を遅延させます。そのとき、RubyはaSongのクラスを見て、そのクラスがメッセージと同じ名前のメソッドを実装していれば、そのメソッドを実行します。もし見つからなければ、Rubyは親クラス、さらに親クラスを遡って探します。もし適切なメソッドが見つからなければ、特別な処理が行われ、通常はエラーが発生します。

では、私たちの例に戻りましょう。to_sメソッドをaSongというKaraokeSongクラスのオブジェクトに送ったところ、RubyはKaraokeSongクラス内でto_sメソッドを見つけられませんでした。そのため、RubyはKaraokeSongの親であるSongクラスを調べ、そこに私たちがページ18で定義したto_sメソッドを見つけたのです。だから、歌詞が表示されないのです。Songクラスは歌詞について何も知りません。

class KaraokeSong
  # ...
  def to_s
    "KS: #{@name}--#{@artist} (#{@duration}) [#{@lyrics}]"
  end
end

再度テストしてみましょう。

aSong = KaraokeSong.new("My Way", "Sinatra", 225, "And now, the...")
aSong.to_s  # => "KS: My Way--Sinatra (225) [And now, the...]"

これで、@lyricsインスタンス変数の値が正しく表示されるようになりました。しかし、この実装には問題があります。なぜなら、親クラスの内部状態に直接アクセスしているからです。これにより、親クラスの実装に強く依存することになります。例えば、もしSongクラスを変更して曲の長さをミリ秒単位で保存するようにした場合、KaraokeSongは突飛な値を表示することになってしまいます。たとえば、「『My Way』のカラオケバージョンが3750分も続く」というのはあまりにも怖すぎます。

この問題を回避するために、各クラスは自分の内部状態を管理します。KaraokeSong#to_sが呼ばれると、まず親のto_sメソッドを呼び出して曲の詳細を取得し、それに歌詞情報を追加して結果を返すようにします。ここで使うのがRubyのsuperキーワードです。superを引数なしで呼び出すと、Rubyは現在のオブジェクトの親にメッセージを送り、親の同名のメソッドを呼び出します。その際、現在のメソッドに渡された引数も親に渡されます。

それでは、新しいto_sメソッドを実装してみましょう。

class KaraokeSong < Song
  # 自分を文字列としてフォーマットするために
  # 親の#to_sの値に歌詞を追加します。
  def to_s
    super + " [#{@lyrics}]"
  end
end

再度テストしてみます。

aSong = KaraokeSong.new("My Way", "Sinatra", 225, "And now, the...")
aSong.to_s  # => "Song: My Way--Sinatra (225) [And now, the...]"

これで、歌詞が正しく表示されるようになりました。また、Songクラスに親クラスが明示的に指定されていませんが、Songクラスは暗黙のうちにObjectクラスを親として持っています。これにより、すべてのオブジェクトはObjectクラスを祖先として持ち、そのインスタンスメソッドはすべてのオブジェクトで利用可能です。to_sもその一例で、Objectクラスに35以上のインスタンスメソッドが定義されています。