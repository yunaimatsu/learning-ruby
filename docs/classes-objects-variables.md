> - 導入
> - 

## 1. 導入

> ### クラスとオブジェクト(インスタンス)の作り方

これまでの例を見て、Rubyがオブジェクト指向言語だという主張を疑っているかもしれません。
この章ではその主張が正しいと証明して差し上げます。
Rubyでクラスとオブジェクトを作成する方法や、Rubyが多くのオブジェクト指向言語よりも強力である点について見ていきます。その過程で、次の億ドルプロダクト、「インターネット対応ジャズ＆ブルーグラスジュークボックス」の一部を実装していきます。

数ヶ月にわたる作業の結果、高給取りの我々R&Dチームは、ジュークボックスには曲が必要だと結論だ、という結論に至りました。
そこで、まずは「曲」を表すRubyのクラスを作成することにしました。
実世界の曲には名前、アーティスト、再生時間があるので、プログラム内の曲オブジェクトにもそれらを持たせる必要があります。

> #### クラス定義

まずは基本的なクラス`Song`を作成し、単一のメソッド`initialize`だけ書いてみました。

```rb
class Song
  def initialize(name, artist, duration)
    @name     = name
    @artist   = artist
    @duration = duration
  end
end
```

> #### オブジェクト作成(インスタンシエーション)

`initialize`はRubyのプログラムで特別なメソッドです。`Song.new`を呼び出して新しい`Song`オブジェクトを作成すると、Rubyは初期化されていないオブジェクトを作成し、そのオブジェクトの`initialize`メソッドを呼び出します。この際、`new`に渡された引数が`initialize`メソッドに渡されます。これにより、オブジェクトの状態を設定するためのコードを書くことができます。

`Song`クラスの場合、`initialize`メソッドは3つのパラメータを受け取ります。
これらのパラメータはメソッド内でローカル変数のように扱われます。
ローカル変数の命名規則に従い、小文字で始まります。

1つのオブジェクトは1つの固有の曲を表しているので、`Song`オブジェクトごとに名前、アーティスト、再生時間を保持する必要があります。これには、オブジェクト(インスタンス)内でインスタンス変数としてこれらの値を保存します。Rubyではインスタンス変数は名前の前に`@`を付けるだけで表現できます。

例えば、インスタンス変数`@name`には値`name`、`@artist`には値`artist`に、`@duration`には値`duration`がそれぞれ割り当てられます。

> `inspect`メソッドによるオブジェクト(インスタンス)の検査

では、この新しいクラスをテストしてみましょう。

```rb
aSong = Song.new("Bicylops", "Fleck", 260)
aSong.inspect  # => "#<Song:0x401b4924 @duration=260, @artist=\"Fleck\", @name=\"Bicylops\">"
```

うまくいったようです！

`inspect`メッセージは任意のオブジェクトにデフォルトで送信できます。

オブジェクトのIDとインスタンス変数が表示されます。インスタンス変数が正しく設定されていることがわかります。

> TIPS: `inspect`の値は`to_s`すると良い

私たちの経験から、開発中に`Song`オブジェクトの内容を何度も印刷することになるでしょうが、`inspect`のデフォルトフォーマットはあまり便利ではありません。幸い、Rubyにはすべてのオブジェクトに対して文字列として表示される`to_s`という標準メソッドがあります。これを曲に試してみましょう。

```rb
aSong = Song.new("Bicylops", "Fleck", 260)
aSong.to_s  # => "#<Song:0x401b499c>"
```

あまり役に立ちませんでしたね…。

オブジェクトIDだけが表示されました。そこで、`to_s`メソッドをクラス内でオーバーライドしてみましょう。この機会に、私たちがこの本でどのようにクラス定義を示しているかについても触れておきましょう。

Rubyでは、クラスは決して閉じられることはありません。既存のクラスに新しいメソッドを追加することができます。これには、自分で作成したクラスだけでなく、標準の組み込みクラスも含まれます。既存のクラス定義を開くことで、新しい内容がそのクラスに追加されます。

これは私たちにとって非常に便利です。この章を通して、クラスに機能を追加していく過程で、新しいメソッドだけをクラス定義として示し、古いものはそのままにしておきます。これにより、各例で冗長なコードを繰り返す必要がなくなります。もちろん、もしこのコードを最初から作成するのであれば、すべてのメソッドを一つのクラス定義内に書くことになるでしょう。

さて、詳細はここまでにして、Songクラスに`to_s`メソッドを追加しましょう。
```rb
class Song
  def to_s
    "Song: #{@name}--#{@artist} (#{@duration})"
  end
end
```
```rb
aSong = Song.new("Bicylops", "Fleck", 260)
aSong.to_s  # => "Song: Bicylops--Fleck (260)"
```

素晴らしい、進展があります。しかし、ここで少し細かい点を見落としました。Rubyがすべてのオブジェクトに`to_s`をサポートしていると述べましたが、その仕組みについては説明していませんでした。その答えは、継承、サブクラス化、そしてRubyがオブジェクトにメッセージを送る際に実行するメソッドの決定方法に関係しています。これは次のセクションで扱う内容です。

## 2. 継承とメッセージ

> 継承とは

継承を使うと、別のクラスを基にして、新しいクラスを作成することができます。

例えば、私たちのジュークボックスには「曲」という概念があり、これを`Song`クラスで表現しています。

そこにマーケ部の人がやってきて、カラオケ機能を追加するように言われました。カラオケの曲は、`Song`オブジェクトの曲とほとんど同じですが（歌声は入っていませんが、それは考えないことにしてください）、歌詞とタイミング情報を持っています。ジュークボックスでカラオケ曲が再生されるとき、歌詞が曲の進行に合わせてジュークボックスの画面に流れるようにしたいです。

この問題に対処するためには、新しいクラス`KaraokeSong`を定義します。`KaraokeSong`は`Song`とほとんど同じですが、歌詞トラックを追加します。

```rb
class KaraokeSong < Song
  def initialize(name, artist, duration, lyrics)
    super(name, artist, duration)
    @lyrics = lyrics
  end
end
```

`< Song`というクラス定義の行は、`KaraokeSong`が`Song`のサブクラスであることをRubyに伝えます。（想像の通り、これにより`Song`は`KaraokeSong`の親クラスになります。親子関係と呼ばれることもあります。）
今のところは、一旦`initialize`メソッドについては心配しないでください。
`super`の使い方については後で説明します。

それでは、`KaraokeSong`を作成して、コードが動作するか確認してみましょう。（最終システムでは、歌詞はテキストとタイミング情報を含むオブジェクトに格納されますが、ここでは単に文字列を使ってテストします。これは型がない言語のもう一つの利点です---コードを実行し始める前にすべてを定義する必要はありません。）

```rb
aSong = KaraokeSong.new("My Way", "Sinatra", 225, "And now, the...")
aSong.to_s  # => "Song: My Way--Sinatra (225)"
```

> `super`を使って

実行はできましたが、なぜ`to_s`メソッドに歌詞が表示されないのでしょうか？

その答えは、メッセージがオブジェクトに送られたときに、どのメソッドの呼び出すかをRubyが決定する方法に関係しています。

Rubyが`aSong.to_s`というメソッド呼び出しをコンパイルするとき、実際には`to_s`メソッドがどこにあるかはわかりません。そのため、プログラムが実行されるまで決定を遅延させます。そのとき、Rubyは`aSong`のクラスを見て、そのクラスがメッセージと同じ名前のメソッドを実装していれば、そのメソッドを実行します。もし見つからなければ、Rubyは親クラス、さらに親クラスを遡って探します。もし適切なメソッドが見つからなければ、特別な処理が行われ、通常はエラーが発生します。

では、私たちの例に戻りましょう。`to_s`メソッドを`aSong`という`KaraokeSong`クラスのオブジェクトに送ったところ、Rubyは`KaraokeSong`クラス内でto_sメソッドを見つけられませんでした。そのため、Rubyは`KaraokeSong`の親である`Song`クラスを調べ、そこに私たちがページ18で定義したto_sメソッドを見つけたのです。だから、歌詞が表示されないのです。`Song`クラスは歌詞について何も知りません。

```rb
class KaraokeSong
  # ...
  def to_s
    "KS: #{@name}--#{@artist} (#{@duration}) [#{@lyrics}]"
  end
end
```

再度テストしてみましょう。

```rb
aSong = KaraokeSong.new("My Way", "Sinatra", 225, "And now, the...")
aSong.to_s  # => "KS: My Way--Sinatra (225) [And now, the...]"
```

これで、`@lyrics`インスタンス変数の値が正しく表示されるようになりました。しかし、この実装には問題があります。なぜなら、親クラスの内部状態に直接アクセスしているからです。これにより、親クラスの実装に強く依存することになります。例えば、もし`Song`クラスを変更して曲の長さをミリ秒単位で保存するようにした場合、`KaraokeSong`は突飛な値を表示することになってしまいます。たとえば、「『My Way』のカラオケバージョンが3750分も続く」というのはあまりにも怖すぎます。

この問題を回避するために、各クラスは自分の内部状態を管理します。`KaraokeSong#to_s`が呼ばれると、まず親の`to_s`メソッドを呼び出して曲の詳細を取得し、それに歌詞情報を追加して結果を返すようにします。ここで使うのがRubyの`super`キーワードです。`super`を引数なしで呼び出すと、Rubyは現在のオブジェクトの親にメッセージを送り、親の同名のメソッドを呼び出します。その際、現在のメソッドに渡された引数も親に渡されます。

それでは、新しい`to_s`メソッドを実装してみましょう。

```rb
class KaraokeSong < Song
  # 自分を文字列としてフォーマットするために
  # 親の#to_sの値に歌詞を追加します。
  def to_s
    super + " [#{@lyrics}]"
  end
end
```

再度テストしてみます。

```rb
aSong = KaraokeSong.new("My Way", "Sinatra", 225, "And now, the...")
aSong.to_s  # => "Song: My Way--Sinatra (225) [And now, the...]"
```

これで、歌詞もちゃんと表示されるようになりました。

> `Object`クラス

また、`Song`クラスに親クラスが明示的に指定されていませんが、`Song`クラスは暗黙のうちに`Object`クラスを親として持っています。これにより、すべてのオブジェクトはObjectクラスを祖先として持ち、そのインスタンスメソッドはすべてのオブジェクトで利用可能です。`to_s`もその一例で、`Object`クラスに35以上のインスタンスメソッドが定義されています。

## 3. 継承とミックスイン

> 多重継承(C++)の力と単一継承(Java)のシンプルさ

一部のオブジェクト指向プログラミング言語（特にC++）では、複数の親を持つことができる「多重継承」がサポートされています。この技法は強力ですが、継承の階層が曖昧になる可能性があるため、危険な場合もあります。

Javaのような言語では、単一継承がサポートされています。ここでは、クラスは1つの親クラスしか持つことができません。単一継承はよりクリーンで実装が簡単ですが、現実世界では物事が複数のソースから属性を引き継ぐことが多いため（例えば、ボールは「バウンスするもの」でも「球形のもの」でもあります）、その欠点もあります。

Rubyは、単一継承のシンプルさと多重継承の力を兼ね備えた面白くて強力な妥協策を提供します。Rubyクラスは1つの直接の親クラスしか持つことができません。したがって、Rubyは単一継承の言語です。しかし、Rubyクラスは任意の数のミックスインを含むことができ、これが多重継承のような能力を提供します。この方法には多重継承の欠点がないため、制御された多重継承のような機能を提供します。ミックスインについては、98ページから詳しく説明します。

> ✍ミクシンのページさがす

これまでの章ではクラスとそのメソッドを見てきましたが、ここでは実際のオブジェクト、例えば Song クラスのインスタンスについて見ていきます。

## 4. オブジェクトと属性

> オブジェクト間のプライバシー

これまでに作成した `Song`オブジェクトには、内部状態（例えば、曲のタイトルやアーティスト）が含まれています。その状態はオブジェクトに対してプライベートであり、他のオブジェクトはオブジェクトのインスタンス変数にアクセスできません。一般的に、これは良いことです。なぜなら、それによってオブジェクト自身がその整合性を保つ責任を持つからです。

> デメリット

しかし、完全に秘密主義なオブジェクトはあまり役に立ちません。オブジェクトを作成できても、その後何もできないからです。

> アクセサーメソッドをゼロから作って中身にアクセスできるようにする

通常、オブジェクトの状態にアクセスしたり操作したりするためのメソッドを定義します。これにより、外部の世界がオブジェクトとやり取りできるようになります。これらの外部から見えるオブジェクトの側面は、その「属性」と呼ばれます。
私たちの`Song`オブジェクトの場合、最初に必要なのは、曲名やアーティストを取得する機能（再生中に表示できるように）と、曲の長さを取得する機能（進行バーを表示できるように）です。
```rb
class Song
  def name
    @name
  end
  def artist
    @artist
  end
  def duration
    @duration
  end
end
```
```rb
aSong = Song.new("Bicylops", "Fleck", 260)
aSong.artist  # => "Fleck"
aSong.name    # => "Bicylops"
aSong.duration  # => 260
```

ここでは、3つのアクセサーメソッドを定義して、3つのインスタンス属性の値を返しています。

> アクセサーメソッドを作る`attr_reader`

これは非常に一般的な手法なので、Rubyでは便利なショートカットを提供しています：`attr_reader`は、これらのアクセサーメソッドを自動的に作成してくれます。
```rb
class Song
  attr_reader :name, :artist, :duration
end
```
```rb
aSong = Song.new("Bicylops", "Fleck", 260)
aSong.artist  # => "Fleck"
aSong.name    # => "Bicylops"
aSong.duration  # => 260
```
この例では新しいものが登場しています。`:artist` という構文は、`artist`に対応する`Symbol`オブジェクトを返す式です。`:artist`は変数`artist`の名前を意味し、`artist`はその変数の値を意味します。この例では、アクセサーメソッドを `name`、`artist`、`duration`と名付けました。対応するインスタンス変数`@name`、`@artist`、`@duration`は自動的に作成されます。これらのアクセサーメソッドは、先に手動で書いたものと全く同じです。

## 5. 書き込み可能な属性

時には、オブジェクトの外部から属性を設定できるようにする必要があります。例えば、曲に最初に関連付けられた再生時間が予測値であると仮定しましょう（例えば、CD情報やMP3データから取得したもの）。曲を初めて再生するときに実際の再生時間を知り、その新しい値をSongオブジェクトに保存します。

C++やJavaなどの言語では、これをセッター関数で行います。
```java
class JavaSong {
  // Javaのコード
  private Duration myDuration;
  public void setDuration(Duration newDuration) {
    myDuration = newDuration;
  }
}
s = new Song(....)
s.setDuration(length)
```
Rubyでは、オブジェクトの属性は他の変数のようにアクセスできます。先ほど見たように、aSong.name というフレーズがその例です。したがって、属性の値を設定したいときにこれらの変数に代入できるのは自然なことです。Rubyでは、これはその通りに動作します（予期しない挙動を避ける原則に従っています）。
```rb
class Song
  def duration=(newDuration)
    @duration = newDuration
  end
end
```
```rb
aSong = Song.new("Bicylops", "Fleck", 260)
aSong.duration  # => 260
aSong.duration = 257   # 属性に新しい値を設定
aSong.duration  # => 257
```
`aSong.duration = 257` という代入は、`aSong`オブジェクト内の`duration=`メソッドを呼び出し、`257`を引数として渡しています。実際、`=`で終わるメソッド名を定義することで、そのメソッド名が代入の左辺に現れることができるようになります。

再び、Rubyではこれらのシンプルな属性設定メソッドを作成するためのショートカットを提供しています。
```rb
class Song
  attr_writer :duration
end
aSong = Song.new("Bicylops", "Fleck", 260)
aSong.duration = 257
```

## 6. 仮想属性

これらの属性アクセサメソッドは、単にオブジェクトのインスタンス変数をラップするだけのものではありません。例えば、これまで秒単位で扱っていた再生時間を、分単位や分の小数点部分でアクセスしたい場合があります。
```rb
class Song
  def durationInMinutes
    @duration / 60.0   # 浮動小数点に強制変換
  end

  def durationInMinutes=(value)
    @duration = (value * 60).to_i
  end
end
```
```rb
aSong = Song.new("Bicylops", "Fleck", 260)
aSong.durationInMinutes  # => 4.333333333
aSong.durationInMinutes = 4.2
aSong.duration  # => 252
```
ここでは、属性メソッドを使って仮想的なインスタンス変数を作成しています。外部から見ると、durationInMinutes は他の属性と同じように見えます。しかし、内部的にはそれに対応するインスタンス変数は存在しません。

これは単なる好奇心からの例ではありません。ベルナール・メイヤーの著書『オブジェクト指向ソフトウェア構築』において、彼はこれを「均一アクセス原則（Uniform Access Principle）」と呼んでいます。インスタンス変数と計算された値の違いを隠すことで、クラスの実装を他の世界から隔離できます。これにより、将来的に実装を変更しても、そのクラスを使用している何百万行ものコードに影響を与えることなく、クラスの使い方に変更を加えることができます。これは大きな利点です。

## クラス変数とクラスメソッド

これまで作成したクラスはすべてインスタンス変数とインスタンスメソッドを含んでいました。インスタンス変数はクラスの特定のインスタンスに関連付けられた変数で、インスタンスメソッドはそれらの変数に対して動作します。しかし、時にはクラス自体が独自の状態を持つ必要があることがあります。これがクラス変数の出番です。


### クラス変数

クラス変数は、クラスのすべてのオブジェクトで共有され、後で説明するクラスメソッドからもアクセスできます。特定のクラスに対してクラス変数は一つだけ存在します。クラス変数の名前は、`@@count`のように`@`を二つ並べて始まります。グローバル変数やインスタンス変数とは異なり、クラス変数は使用する前に初期化する必要があります。この初期化は、クラス定義の本体で単純な代入として行われることがよくあります。

例えば、私たちのジュークボックスが、各曲が再生された回数を記録したい場合を考えます。このカウントは、おそらくSongオブジェクトのインスタンス変数になります。曲が再生されるたびに、そのインスタンスの値が増加します。しかし、もし全曲の再生回数の合計を知りたい場合、すべてのSongオブジェクトを検索してそのカウントを合計するか、グローバル変数を使ってしまうリスクを冒すことになります。その代わりに、クラス変数を使うことができます。
```rb
class Song
  @@plays = 0
  def initialize(name, artist, duration)
    @name     = name
    @artist   = artist
    @duration = duration
    @plays    = 0
  end
  def play
    @plays += 1
    @@plays += 1
    "This song: #@plays plays. Total #@@plays plays."
  end
end
```
デバッグのために、`Song#play`がこの曲が再生された回数と、すべての曲の合計再生回数を含む文字列を返すようにしています。簡単にテストできます。
```rb
s1 = Song.new("Song1", "Artist1", 234)  # test songs..
s2 = Song.new("Song2", "Artist2", 345)
s1.play	# => "This song: 1 plays. Total 1 plays."
s2.play	# => "This song: 1 plays. Total 2 plays."
s1.play	# => "This song: 2 plays. Total 3 plays."
s1.play	# => "This song: 3 plays. Total 4 plays."
```
クラス変数はクラスとそのインスタンスに対してプライベートです。外部からアクセスできるようにしたい場合は、アクセサメソッドを作成する必要があります。このメソッドはインスタンスメソッドであっても、次のセクションに進むためにクラスメソッドであっても構いません。

### クラスメソッド

時には、クラスが特定のオブジェクトに結びつかずに動作するメソッドを提供する必要があります。これまでに、newメソッドがその一例です。このメソッドは新しいSongオブジェクトを作成しますが、特定の曲に関連付けられているわけではありません。

aSong = Song.new(....)

Rubyのライブラリには、クラスメソッドが数多く存在します。例えば、Fileクラスのオブジェクトは、基盤となるファイルシステムで開かれているファイルを表します。しかし、Fileクラス自体には開かれていないファイルを操作するためのクラスメソッドもいくつかあります。ファイルを削除したい場合は、File.deleteというクラスメソッドを呼び出し、ファイル名を渡します。

File.delete("doomedFile")

クラスメソッドは、インスタンスメソッドとは定義方法が異なります。クラスメソッドは、メソッド名の前にクラス名とピリオドを置くことで定義されます。

class Example
  def instMeth              # インスタンスメソッド
  end

  def Example.classMeth     # クラスメソッド
  end
end

ジュークボックスは、曲ごとに料金を請求しますが、分単位ではなく曲単位で料金を設定します。これにより、短い曲の方が長い曲よりも収益性が高くなります。そこで、特定の曲が長すぎてSongListに追加できないようにするためのクラスメソッドをSongListに定義することができます。この制限を設定するために、クラス定数（大文字で始まる定数）をクラス内で初期化します。

class SongList
  MaxTime = 5*60           # 5分
  def SongList.isTooLong(aSong)
    return aSong.duration > MaxTime
  end
end

以下のように、Songオブジェクトを作成し、SongListクラスのクラスメソッドisTooLongを呼び出すことができます。

song1 = Song.new("Bicylops", "Fleck", 260)
SongList.isTooLong(song1)  # => false

song2 = Song.new("The Calling", "Santana", 468)
SongList.isTooLong(song2)


## 10. シングルトンとその他のコンストラクタ

時には、Rubyがオブジェクトを作成するデフォルトの方法をオーバーライドしたい場合があります。例えば、私たちのジュークボックスを見てみましょう。ジュークボックスは全国に広がっているため、メンテナンスをできるだけ簡単にしたいと考えています。その要件の一部は、ジュークボックスで起こるすべてのことを記録することです。再生された曲や受け取ったお金、ジュークボックスに注がれた奇妙な液体などです。音楽のためにネットワーク帯域を確保したいため、これらのログファイルはローカルに保存することにします。このため、ログを管理するクラスが必要ですが、ジュークボックスごとに1つのログオブジェクトだけが必要で、すべての他のオブジェクトでそのオブジェクトを共有したいと考えています。

ここで登場するのがシングルトンパターンです。シングルトンパターンを使うことで、ログオブジェクトを作成する唯一の方法はLogger.createを呼び出すことになり、ログオブジェクトが1つだけ作成されることが保証されます。
```rb
class Logger
  private_class_method :new
  @@logger = nil
  def Logger.create
    @@logger = new unless @@logger
    @@logger
  end
end
```
`Logger`の`new`メソッドをプライベートにすることで、従来のコンストラクタを使用してログオブジェクトを作成することを防ぎます。その代わりに、`Logger.create`というクラスメソッドを提供します。このメソッドはクラス変数`@@logger`を使用して、ログのインスタンスへの参照を保持し、呼び出すたびにそのインスタンスを返します。

[ここで紹介するシングルトンの実装はスレッドセーフではありません。複数のスレッドが動作している場合、複数のログオブジェクトが作成される可能性があります。スレッドセーフを追加する代わりに、Rubyが提供するシングルトンミックスインを使用するのが一般的です。詳細はページ468に記載されています。] 実際に、メソッドが返すオブジェクト識別子を見て確認することができます。
```rb
Logger.create.id   # => 537766930
Logger.create.id   # => 537766930
```
クラスメソッドを擬似コンストラクタとして使用することは、クラスのユーザーにとっても便利です。簡単な例として、正多角形を表すShapeクラスを見てみましょう。Shapeのインスタンスは、必要な辺の数と周囲長を指定することで作成されます。
```rb
class Shape
  def initialize(numSides, perimeter)
    # ...
  end
end
```
しかし、数年後、このクラスが別のアプリケーションで使用され、プログラマーたちは形状を名前で作成し、周囲長ではなく辺の長さを指定することに慣れているとします。この場合、クラスメソッドを追加するだけで対応できます。

class Shape
  def Shape.triangle(sideLength)
    Shape.new(3, sideLength*3)
  end

  def Shape.square(sideLength)
    Shape.new(4, sideLength*4)
  end
end

クラスメソッドには興味深く強力な使い方がたくさんありますが、それを探ることがジュークボックスを完成させるのを早くするわけではないので、ここで話は終わりにしましょう。

## 11. アクセス制御

クラスインターフェースを設計する際には、クラスが外部に対してどれくらいのアクセスを許可するかを慎重に考慮することが重要です。クラスへのアクセスを過剰に許可すると、アプリケーションの結合度が高くなり、クラスのユーザーがクラスの論理的インターフェースではなく、実装の詳細に依存することになりかねません。良いニュースは、Rubyではオブジェクトの状態を変更する唯一の方法は、そのメソッドの1つを呼び出すことだという点です。メソッドへのアクセスを制御することで、オブジェクトへのアクセスも制御できます。良い指針として、オブジェクトを無効な状態にする可能性のあるメソッドは公開しないことです。Rubyには3つのアクセスレベルがあります。

公開メソッド (Public methods): 誰でも呼び出すことができます。アクセス制御はありません。メソッドはデフォルトで公開されており（initializeを除く）、initializeは常にプライベートです。

保護メソッド (Protected methods): 定義したクラスとそのサブクラスのオブジェクトからのみ呼び出すことができます。アクセスは「家族内」で管理されます。

プライベートメソッド (Private methods): 明示的な受け手を指定して呼び出すことはできません。プライベートメソッドは、定義したクラス内およびそのオブジェクト内の直接の子孫クラスからのみ呼び出すことができます。


「protected」と「private」の違いはかなり微妙で、Rubyは他の多くのオブジェクト指向言語とは異なります。もしメソッドが保護されている場合、そのメソッドは定義したクラスの任意のインスタンスまたはそのサブクラスから呼び出すことができます。一方、プライベートメソッドは、呼び出し元オブジェクトの文脈内でのみ呼び出すことができ、他のオブジェクトのプライベートメソッドには直接アクセスできません（たとえそのオブジェクトが呼び出し元と同じクラスであっても）。

Rubyは、他のオブジェクト指向言語とは別の重要な点でも異なります。アクセス制御は静的ではなく、プログラムが実行される際に動的に決定されます。制限されたメソッドを実行しようとした時にのみ、アクセス違反が発生します。

## 12. アクセス制御の指定

クラスやモジュールの定義内で、public、protected、private の3つの関数を使って、メソッドのアクセスレベルを指定します。これらの関数は、2通りの使い方があります。

引数なしで使う場合、3つの関数はその後に定義されたメソッドのデフォルトのアクセス制御を設定します。この動作は、C++ や Java のプログラマーには馴染み深いもので、同様の効果を得るために public などのキーワードを使用します。

class MyClass

  def method1    # デフォルトは 'public'
    #...
  end

  protected      # 次のメソッドは 'protected'

  def method2    # 'protected' になります
    #...
  end

  private        # 次のメソッドは 'private'

  def method3    # 'private' になります
    #...
  end

  public         # 次のメソッドは 'public'

  def method4    # 'public' になります
    #...
  end
end

また、アクセスレベルを指定する関数にメソッド名を引数として渡すことによって、特定のメソッドのアクセスレベルを設定することもできます。

class MyClass

  def method1
  end

  # ... そして続きます

  public    :method1, :method4
  protected :method2
  private   :method3
end

クラスの initialize メソッドは自動的に private として宣言されます。

次にいくつかの例を見てみましょう。例えば、会計システムをモデル化している場合、各デビットに対応するクレジットがあります。このルールを破らないように、デビットとクレジットのメソッドをプライベートにし、外部インターフェースをトランザクションに基づいて定義することができます。

class Accounts

  private

    def debit(account, amount)
      account.balance -= amount
    end
    def credit(account, amount)
      account.balance += amount
    end

  public

    #...
    def transferToSavings(amount)
      debit(@checking, amount)
      credit(@savings, amount)
    end
    #...
end

protected アクセスは、オブジェクトが同じクラスの他のオブジェクトの内部状態にアクセスする必要がある場合に使用されます。例えば、Account オブジェクトが自身の生の残高を比較できるようにしたい場合、他のクラスからはその残高を隠したいときに使います。

class Account
  attr_reader :balance       # アクセサーメソッド 'balance'

  protected :balance         # これを保護されたメソッドにします

  def greaterBalanceThan(other)
    return @balance > other.balance
  end
end

balance 属性は protected であるため、Account オブジェクト内でのみアクセス可能です。



## 13. 変数

これまで作成したすべてのオブジェクトを失わないようにするためには、変数を使用してオブジェクトを管理します。変数はオブジェクトへの参照を保持します。

まず、コードで確認してみましょう。

person = "Tim"
person.id    # 537771100
person.type  # String
person       # "Tim"

最初の行で、Rubyは「Tim」という値を持つ新しいStringオブジェクトを作成します。このオブジェクトへの参照がローカル変数`person`に格納されます。クイックチェックを行うと、変数は確かに文字列の性質を持ち、オブジェクトID、タイプ、値を持っていることが確認できます。

では、変数はオブジェクトなのでしょうか？

Rubyでは、答えは「いいえ」です。変数は単なるオブジェクトへの参照です。オブジェクトはどこかの大きなプール（ほとんどの場合はヒープ）に浮かんでおり、変数はそのオブジェクトを指し示します。

次に、少し複雑な例を見てみましょう。

person1 = "Tim"
person2 = person1
person1[0] = 'J'
person1    # "Jim"
person2    # "Jim"

ここで何が起こったのでしょうか？`person1`の最初の文字を変更しましたが、`person1`と`person2`の両方が「Tim」から「Jim」に変わっています。

これは、変数がオブジェクトへの参照を保持しているという事実に戻ります。`person1`を`person2`に代入しても、新しいオブジェクトは作成されません。単に`person1`のオブジェクト参照を`person2`にコピーするだけなので、`person1`と`person2`は同じオブジェクトを参照していることになります。この点は、図3.1（31ページ）に示されています。

代入はオブジェクトをエイリアス化し、複数の変数が同じオブジェクトを参照する可能性があります。しかし、これがコードに問題を引き起こすことはあるのでしょうか?
それほど頻繁にはないですが（例えば、Javaのオブジェクトも全く同じように動作します）。例えば、図3.1の例では、`dup`メソッドを使用して String の新しいオブジェクトを作成し、エイリアスを避けることができます。
```rb
person1 = "Tim"
person2 = person1.dup
person1[0] = "J"
person1    # "Jim"
person2    # "Tim"
```
また、オブジェクトを変更できないようにするためには、freeze メソッドを使用することができます（オブジェクトの凍結については251ページで説明します）。凍結されたオブジェクトを変更しようとすると、Rubyは TypeError の例外を発生させます。

person1 = "Tim"
person2 = person1
person1.freeze       # オブジェクトの変更を防止
person2[0] = "J"     # 変更しようとするとエラーが発生

出力:

prog.rb:4:in `=': can't modify frozen string (TypeError)
	from prog.rb:4