## 1. コンテナ、ブロック、イテレータ

1曲だけのジュークボックスは人気が出ないでしょう（ごく一部の非常に怖いバーを除いて）。そのため、すぐにカタログと再生リストを作成し、再生する曲のリストを管理する必要が出てきます。これらはどちらもコンテナです。コンテナとは、1つまたは複数の他のオブジェクトへの参照を保持するオブジェクトのことです。

カタログと再生リストには、曲を追加する、削除する、曲のリストを返す、といった似たようなメソッドが必要です。再生リストは、広告を挿入したり、累積再生時間を追跡したりといった追加のタスクを実行するかもしれませんが、その点については後で考えることにしましょう。とりあえず、カタログと再生リストの両方に対応できるような、汎用的なSongListクラスを開発するのが良いアイデアです。

## 2. コンテナ

実装を始める前に、SongListオブジェクト内に曲のリストをどのように格納するかを考える必要があります。ここで考えられる選択肢は3つあります。RubyのArray型を使う、RubyのHash型を使う、または自分でリスト構造を作成するという方法です。今回は面倒なので、ArrayとHashを見てみて、どちらかをクラスに使うことにしましょう。

## 3. 配列

クラスArrayは、オブジェクトの参照のコレクションを保持します。各オブジェクトの参照は、配列内の位置を表す非負の整数インデックスによって識別されます。

配列は、リテラルを使用するか、明示的にArrayオブジェクトを作成して作成できます。リテラル配列は、単に角括弧内にオブジェクトを並べたものです。

a = [ 3.14159, "pie", 99 ]
a.type    # => Array
a.length  # => 3
a[0]      # => 3.14159
a[1]      # => "pie"
a[2]      # => 99
a[3]      # => nil

b = Array.new
b.type    # => Array
b.length  # => 0
b[0] = "second"
b[1] = "array"
b  # => ["second", "array"]

配列は[]演算子を使ってインデックス指定します。ほとんどのRubyの演算子と同様に、これは実際にはメソッド（Arrayクラス内）であり、サブクラスでオーバーライドすることができます。上記の例のように、配列のインデックスは0から始まります。単一の整数で配列をインデックス指定すると、その位置にあるオブジェクトが返されます。もしそこにオブジェクトがなければ、nilが返されます。負の整数でインデックス指定すると、配列の末尾からカウントされます。

a = [ 1, 3, 5, 7, 9 ]
a[-1]  # => 9
a[-2]  # => 7
a[-99] # => nil

また、配列は2つの数値（[start, count]）を使ってインデックス指定できます。これは、start位置からcount個のオブジェクトを参照する新しい配列を返します。

a = [ 1, 3, 5, 7, 9 ]
a[1, 3]  # => [3, 5, 7]
a[3, 1]  # => [7]
a[-3, 2] # => [5, 7]

最後に、範囲を使って配列をインデックス指定できます。範囲は2つまたは3つのドットで区切られた開始位置と終了位置で構成されます。2ドット形式は終了位置を含み、3ドット形式は終了位置を含みません。

a = [ 1, 3, 5, 7, 9 ]
a[1..3]  # => [3, 5, 7]
a[1...3] # => [3, 5]
a[3..3]  # => [7]
a[-3..-1] # => [5, 7, 9]

[]演算子には対応する[]=演算子があり、これを使って配列の要素を設定できます。単一の整数インデックスで使用すると、その位置の要素が右辺の値で置き換えられます。結果として空白ができた場合は、nilで埋められます。

a = [ 1, 3, 5, 7, 9 ]  # => [1, 3, 5, 7, 9]
a[1] = 'bat'  # => [1, "bat", 5, 7, 9]
a[-3] = 'cat' # => [1, "bat", "cat", 7, 9]
a[3] = [ 9, 8 ] # => [1, "bat", "cat", [9, 8], 9]
a[6] = 99 # => [1, "bat", "cat", [9, 8], 9, nil, 99]

インデックスが2つの数（開始位置と長さ）や範囲の場合、その位置にある要素が右辺の値で置き換えられます。長さがゼロの場合、右辺の値は開始位置の前に挿入され、要素は削除されません。右辺が配列の場合、その要素が置き換えに使用されます。右辺の要素数と元の配列の要素数が異なる場合でも、配列のサイズは自動的に調整されます。

a = [ 1, 3, 5, 7, 9 ]  # => [1, 3, 5, 7, 9]
a[2, 2] = 'cat'  # => [1, 3, "cat", 9]
a[2, 0] = 'dog'  # => [1, 3, "dog", "cat", 9]
a[1, 1] = [ 9, 8, 7 ]  # => [1, 9, 8, 7, "dog", "cat", 9]
a[0..3] = []  # => ["dog", "cat", 9]
a[5] = 99  # => ["dog", "cat", 9, nil, nil, 99]

配列には、スタック、セット、キュー、デキュー、FIFOとして扱うための便利なメソッドが多数あります。配列メソッドの完全なリストは278ページから始まります。

