## 1. 導入

これまでジュークボックスのコードの一部を実装して楽しんできましたが、少し怠っていた部分があります。配列、ハッシュ、プロックについては触れましたが、Rubyの他の基本的な型――数値、文字列、範囲、正規表現――については十分に扱ってきませんでした。これらの基本的な構成要素について、これから少しページを割いて学んでいきましょう。

## 2. 数値
Rubyは整数と浮動小数点数をサポートしています。整数は任意の長さを持つことができ（システムの空きメモリによって最大値が決まります）、一定の範囲内の整数（通常は-230から230-1または-262から262-1）は内部的に2進数形式で保持され、Fixnumクラスのオブジェクトとして扱われます。この範囲を超える整数は、Bignumクラスのオブジェクトとして格納されます（現在は可変長の短整数のセットとして実装されています）。この変換は透明で、Rubyは自動的に変換を管理します。

num = 8
7.times do
  print num.type, " ", num, "\n"
  num *= num
end

出力：

Fixnum 8
Fixnum 64
Fixnum 4096
Fixnum 16777216
Bignum 281474976710656
Bignum 79228162514264337593543950336
Bignum 6277101735386680763835789423207666416102355444464034512896

整数は、オプションで先頭に符号を付けたり、オプションで基数の指示子（0は8進数、0xは16進数、0bは2進数）を付け、その後に適切な基数の数字を並べることで記述できます。数字の文字列内のアンダースコアは無視されます。

123456                    # Fixnum
123_456                   # Fixnum（アンダースコアは無視される）
-543                      # 負のFixnum
123_456_789_123_345_789   # Bignum
0xaabb                    # 16進数
0377                      # 8進数
-0b101_010                # 2進数（負）

また、ASCII文字やエスケープシーケンスに対応する整数値を取得するためには、その前に疑問符を付けて記述できます。制御文字やメタ文字の組み合わせも、?\C-x、?\M-x、?\M-\C-xを使って生成できます。制御バージョンの値は「value & 0x9f」、メタバージョンの値は「value | 0x80」で生成されます。最後に、?\C-?はASCIIの削除（0177）を生成します。

?a                        # 文字コード
?\n                       # 改行コード (0x0a)
?\C-a                     # 制御文字a = ?A & 0x9f = 0x01
?\M-a                     # メタ文字a（ビット7をセット）
?\M-\C-a                  # メタと制御のa
?\C-?                     # 削除文字

小数点や指数を含む数値リテラルは、Floatオブジェクトに変換され、これはネイティブアーキテクチャの倍精度浮動小数点型に対応します。小数点の後には必ず数字が必要です。例えば、1.e3はFixnumクラスのメソッドe3を呼び出そうとしてしまうためエラーになります。

すべての数値はオブジェクトであり、さまざまなメッセージに応答します（詳細は290ページ、313ページ、315ページ、323ページ、349ページで説明されています）。そのため、例えばC++のように数値の絶対値を求める場合、aNumber.absと書きます。abs(aNumber)とは書きません。

整数はまた、いくつかの便利なイテレータをサポートしています。すでに1つ見ました――7.timesは47ページのコード例で使われています。他にも、2つの整数間で上下に反復処理を行うuptoやdownto、従来のforループに近いstepがあります。

3.times        { print "X " }
1.upto(5)      { |i| print i, " " }
99.downto(95)  { |i| print i, " " }
50.step(80, 5) { |i| print i, " " }

出力：

X X X 1 2 3 4 5 99 98 97 96 95 50 55 60 65 70 75 80

最後に、Perlユーザーへの警告です。数字を含む文字列は、式で使用される際に自動的に数値に変換されません。これは、ファイルから数字を読み取るときに最もよく問題になります。次のコードは（おそらく）意図した動作をしません。

DATA.each do |line|
  vals = line.split    # 行を分割し、トークンをvalsに格納
  print vals[0] + vals[1], " "
end

ファイルの内容が以下である場合：

3 4
5 6
7 8

出力は次のようになります：

34 56 78

何が起こったのでしょうか？

問題は、入力が数値ではなく文字列として読み込まれたことです。プラス演算子は文字列を連結するので、その結果としてそのような出力が得られます。これを修正するには、String#to_iメソッドを使って文字列を整数に変換する必要があります。

DATA.each do |line|
  vals = line.split
  print vals[0].to_i + vals[1].to_i, " "
end

出力：

7 11 15

## 3. 文字列
Rubyの文字列は、単純に8ビットバイトのシーケンスです。通常は印刷可能な文字を保持しますが、それは必須ではなく、文字列はバイナリデータも保持できます。文字列はStringクラスのオブジェクトです。

文字列は、文字列リテラル（区切り文字で囲まれた文字のシーケンス）を使ってよく作成されます。プログラムのソース内でバイナリデータを表現するのが難しいため、文字列リテラルにはさまざまなエスケープシーケンスを挿入できます。これらは、プログラムがコンパイルされる際に対応するバイナリ値に置き換えられます。文字列の区切り文字の種類によって、行われる置換の度合いが決まります。シングルクォーテーションで囲まれた文字列内では、2つの連続したバックスラッシュが1つのバックスラッシュに置き換えられ、バックスラッシュの後にシングルクォーテーションが続くと、シングルクォーテーションになります。

'escape using "\"'  →  escape using "" 'That's right'  →  That's right

ダブルクォーテーションで囲まれた文字列では、さらに多くのエスケープシーケンスをサポートしています。最も一般的なのはおそらく\n、つまり改行文字です。完全なリストはページ203の表18.2に記載されています。また、#{ expr }の形式で、文字列に任意のRuby式の値を埋め込むことができます。式がグローバル変数、クラス変数、インスタンス変数だけの場合は、波括弧を省略できます。

"Seconds/day: #{246060}"  →  Seconds/day: 86400
"#{'Ho! '*3}Merry Christmas"  →  Ho! Ho! Ho! Merry Christmas
"This is line #$."  →  This is line 3

文字列リテラルを構築する方法は他にも3つあります：%q、%Q、および「ヒアドキュメント」です。

%qと%Qは、それぞれシングルクォーテーションとダブルクォーテーションで囲まれた文字列を作成します。
%q/general single-quoted string/  →  general single-quoted string
%Q!general double-quoted string!  →  general double-quoted string
%Q{Seconds/day: #{246060}}  →  Seconds/day: 86400

qやQの後に続く文字が区切り文字です。区切り文字が開き括弧、波括弧、丸括弧、または小なり記号の場合、対応する閉じる記号が見つかるまで文字列が読み込まれます。それ以外の場合は、次に同じ区切り文字が現れるまで文字列が読み込まれます。

最後に、ヒアドキュメントを使って文字列を構築できます。

aString = <<END_OF_STRING
    The body of the string
    is the input lines up to
    one ending with the same
    text that followed the '<<'
END_OF_STRING

ヒアドキュメントは、ソース内の行を指定した終了文字列まで読み込みますが、終了文字列自体は含まれません。通常、この終了文字列は最初の列から始める必要があります。しかし、<<の後にハイフンを付けると、終了文字列をインデントすることができます。

print <<-STRING1, <<-STRING2
   Concat
   STRING1
      enate
      STRING2

出力は次の通りです：

Concat
        enate

